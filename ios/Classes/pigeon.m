// Autogenerated from Pigeon (v4.2.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon
#import "pigeon.h"
#import <Flutter/Flutter.h>

#if !__has_feature(objc_arc)
#error File requires ARC to be enabled.
#endif

static NSDictionary<NSString *, id> *wrapResult(id result, FlutterError *error) {
  NSDictionary *errorDict = (NSDictionary *)[NSNull null];
  if (error) {
    errorDict = @{
        @"code": (error.code ?: [NSNull null]),
        @"message": (error.message ?: [NSNull null]),
        @"details": (error.details ?: [NSNull null]),
        };
  }
  return @{
      @"result": (result ?: [NSNull null]),
      @"error": errorDict,
      };
}
static id GetNullableObject(NSDictionary* dict, id key) {
  id result = dict[key];
  return (result == [NSNull null]) ? nil : result;
}
static id GetNullableObjectAtIndex(NSArray* array, NSInteger key) {
  id result = array[key];
  return (result == [NSNull null]) ? nil : result;
}


@interface CosXmlServiceConfig ()
+ (CosXmlServiceConfig *)fromMap:(NSDictionary *)dict;
+ (nullable CosXmlServiceConfig *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface TransferConfig ()
+ (TransferConfig *)fromMap:(NSDictionary *)dict;
+ (nullable TransferConfig *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface SessionQCloudCredentials ()
+ (SessionQCloudCredentials *)fromMap:(NSDictionary *)dict;
+ (nullable SessionQCloudCredentials *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface CosXmlClientException ()
+ (CosXmlClientException *)fromMap:(NSDictionary *)dict;
+ (nullable CosXmlClientException *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface CosXmlServiceException ()
+ (CosXmlServiceException *)fromMap:(NSDictionary *)dict;
+ (nullable CosXmlServiceException *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface Owner ()
+ (Owner *)fromMap:(NSDictionary *)dict;
+ (nullable Owner *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface Bucket ()
+ (Bucket *)fromMap:(NSDictionary *)dict;
+ (nullable Bucket *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface ListAllMyBuckets ()
+ (ListAllMyBuckets *)fromMap:(NSDictionary *)dict;
+ (nullable ListAllMyBuckets *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface CommonPrefixes ()
+ (CommonPrefixes *)fromMap:(NSDictionary *)dict;
+ (nullable CommonPrefixes *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface Content ()
+ (Content *)fromMap:(NSDictionary *)dict;
+ (nullable Content *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface BucketContents ()
+ (BucketContents *)fromMap:(NSDictionary *)dict;
+ (nullable BucketContents *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end

@implementation CosXmlServiceConfig
+ (instancetype)makeWithRegion:(nullable NSString *)region
    connectionTimeout:(nullable NSNumber *)connectionTimeout
    socketTimeout:(nullable NSNumber *)socketTimeout
    isHttps:(nullable NSNumber *)isHttps
    host:(nullable NSString *)host
    hostFormat:(nullable NSString *)hostFormat
    port:(nullable NSNumber *)port
    isDebuggable:(nullable NSNumber *)isDebuggable
    signInUrl:(nullable NSNumber *)signInUrl
    userAgent:(nullable NSString *)userAgent
    dnsCache:(nullable NSNumber *)dnsCache
    accelerate:(nullable NSNumber *)accelerate {
  CosXmlServiceConfig* pigeonResult = [[CosXmlServiceConfig alloc] init];
  pigeonResult.region = region;
  pigeonResult.connectionTimeout = connectionTimeout;
  pigeonResult.socketTimeout = socketTimeout;
  pigeonResult.isHttps = isHttps;
  pigeonResult.host = host;
  pigeonResult.hostFormat = hostFormat;
  pigeonResult.port = port;
  pigeonResult.isDebuggable = isDebuggable;
  pigeonResult.signInUrl = signInUrl;
  pigeonResult.userAgent = userAgent;
  pigeonResult.dnsCache = dnsCache;
  pigeonResult.accelerate = accelerate;
  return pigeonResult;
}
+ (CosXmlServiceConfig *)fromMap:(NSDictionary *)dict {
  CosXmlServiceConfig *pigeonResult = [[CosXmlServiceConfig alloc] init];
  pigeonResult.region = GetNullableObject(dict, @"region");
  pigeonResult.connectionTimeout = GetNullableObject(dict, @"connectionTimeout");
  pigeonResult.socketTimeout = GetNullableObject(dict, @"socketTimeout");
  pigeonResult.isHttps = GetNullableObject(dict, @"isHttps");
  pigeonResult.host = GetNullableObject(dict, @"host");
  pigeonResult.hostFormat = GetNullableObject(dict, @"hostFormat");
  pigeonResult.port = GetNullableObject(dict, @"port");
  pigeonResult.isDebuggable = GetNullableObject(dict, @"isDebuggable");
  pigeonResult.signInUrl = GetNullableObject(dict, @"signInUrl");
  pigeonResult.userAgent = GetNullableObject(dict, @"userAgent");
  pigeonResult.dnsCache = GetNullableObject(dict, @"dnsCache");
  pigeonResult.accelerate = GetNullableObject(dict, @"accelerate");
  return pigeonResult;
}
+ (nullable CosXmlServiceConfig *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [CosXmlServiceConfig fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"region" : (self.region ?: [NSNull null]),
    @"connectionTimeout" : (self.connectionTimeout ?: [NSNull null]),
    @"socketTimeout" : (self.socketTimeout ?: [NSNull null]),
    @"isHttps" : (self.isHttps ?: [NSNull null]),
    @"host" : (self.host ?: [NSNull null]),
    @"hostFormat" : (self.hostFormat ?: [NSNull null]),
    @"port" : (self.port ?: [NSNull null]),
    @"isDebuggable" : (self.isDebuggable ?: [NSNull null]),
    @"signInUrl" : (self.signInUrl ?: [NSNull null]),
    @"userAgent" : (self.userAgent ?: [NSNull null]),
    @"dnsCache" : (self.dnsCache ?: [NSNull null]),
    @"accelerate" : (self.accelerate ?: [NSNull null]),
  };
}
@end

@implementation TransferConfig
+ (instancetype)makeWithForceSimpleUpload:(nullable NSNumber *)forceSimpleUpload
    enableVerification:(nullable NSNumber *)enableVerification
    divisionForUpload:(nullable NSNumber *)divisionForUpload
    sliceSizeForUpload:(nullable NSNumber *)sliceSizeForUpload {
  TransferConfig* pigeonResult = [[TransferConfig alloc] init];
  pigeonResult.forceSimpleUpload = forceSimpleUpload;
  pigeonResult.enableVerification = enableVerification;
  pigeonResult.divisionForUpload = divisionForUpload;
  pigeonResult.sliceSizeForUpload = sliceSizeForUpload;
  return pigeonResult;
}
+ (TransferConfig *)fromMap:(NSDictionary *)dict {
  TransferConfig *pigeonResult = [[TransferConfig alloc] init];
  pigeonResult.forceSimpleUpload = GetNullableObject(dict, @"forceSimpleUpload");
  pigeonResult.enableVerification = GetNullableObject(dict, @"enableVerification");
  pigeonResult.divisionForUpload = GetNullableObject(dict, @"divisionForUpload");
  pigeonResult.sliceSizeForUpload = GetNullableObject(dict, @"sliceSizeForUpload");
  return pigeonResult;
}
+ (nullable TransferConfig *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [TransferConfig fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"forceSimpleUpload" : (self.forceSimpleUpload ?: [NSNull null]),
    @"enableVerification" : (self.enableVerification ?: [NSNull null]),
    @"divisionForUpload" : (self.divisionForUpload ?: [NSNull null]),
    @"sliceSizeForUpload" : (self.sliceSizeForUpload ?: [NSNull null]),
  };
}
@end

@implementation SessionQCloudCredentials
+ (instancetype)makeWithSecretId:(NSString *)secretId
    secretKey:(NSString *)secretKey
    token:(NSString *)token
    startTime:(nullable NSNumber *)startTime
    expiredTime:(NSNumber *)expiredTime {
  SessionQCloudCredentials* pigeonResult = [[SessionQCloudCredentials alloc] init];
  pigeonResult.secretId = secretId;
  pigeonResult.secretKey = secretKey;
  pigeonResult.token = token;
  pigeonResult.startTime = startTime;
  pigeonResult.expiredTime = expiredTime;
  return pigeonResult;
}
+ (SessionQCloudCredentials *)fromMap:(NSDictionary *)dict {
  SessionQCloudCredentials *pigeonResult = [[SessionQCloudCredentials alloc] init];
  pigeonResult.secretId = GetNullableObject(dict, @"secretId");
  NSAssert(pigeonResult.secretId != nil, @"");
  pigeonResult.secretKey = GetNullableObject(dict, @"secretKey");
  NSAssert(pigeonResult.secretKey != nil, @"");
  pigeonResult.token = GetNullableObject(dict, @"token");
  NSAssert(pigeonResult.token != nil, @"");
  pigeonResult.startTime = GetNullableObject(dict, @"startTime");
  pigeonResult.expiredTime = GetNullableObject(dict, @"expiredTime");
  NSAssert(pigeonResult.expiredTime != nil, @"");
  return pigeonResult;
}
+ (nullable SessionQCloudCredentials *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [SessionQCloudCredentials fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"secretId" : (self.secretId ?: [NSNull null]),
    @"secretKey" : (self.secretKey ?: [NSNull null]),
    @"token" : (self.token ?: [NSNull null]),
    @"startTime" : (self.startTime ?: [NSNull null]),
    @"expiredTime" : (self.expiredTime ?: [NSNull null]),
  };
}
@end

@implementation CosXmlClientException
+ (instancetype)makeWithErrorCode:(NSNumber *)errorCode
    message:(nullable NSString *)message
    details:(nullable NSString *)details {
  CosXmlClientException* pigeonResult = [[CosXmlClientException alloc] init];
  pigeonResult.errorCode = errorCode;
  pigeonResult.message = message;
  pigeonResult.details = details;
  return pigeonResult;
}
+ (CosXmlClientException *)fromMap:(NSDictionary *)dict {
  CosXmlClientException *pigeonResult = [[CosXmlClientException alloc] init];
  pigeonResult.errorCode = GetNullableObject(dict, @"errorCode");
  NSAssert(pigeonResult.errorCode != nil, @"");
  pigeonResult.message = GetNullableObject(dict, @"message");
  pigeonResult.details = GetNullableObject(dict, @"details");
  return pigeonResult;
}
+ (nullable CosXmlClientException *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [CosXmlClientException fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"errorCode" : (self.errorCode ?: [NSNull null]),
    @"message" : (self.message ?: [NSNull null]),
    @"details" : (self.details ?: [NSNull null]),
  };
}
@end

@implementation CosXmlServiceException
+ (instancetype)makeWithStatusCode:(NSNumber *)statusCode
    httpMsg:(nullable NSString *)httpMsg
    requestId:(nullable NSString *)requestId
    errorCode:(nullable NSString *)errorCode
    errorMessage:(nullable NSString *)errorMessage
    serviceName:(nullable NSString *)serviceName
    details:(nullable NSString *)details {
  CosXmlServiceException* pigeonResult = [[CosXmlServiceException alloc] init];
  pigeonResult.statusCode = statusCode;
  pigeonResult.httpMsg = httpMsg;
  pigeonResult.requestId = requestId;
  pigeonResult.errorCode = errorCode;
  pigeonResult.errorMessage = errorMessage;
  pigeonResult.serviceName = serviceName;
  pigeonResult.details = details;
  return pigeonResult;
}
+ (CosXmlServiceException *)fromMap:(NSDictionary *)dict {
  CosXmlServiceException *pigeonResult = [[CosXmlServiceException alloc] init];
  pigeonResult.statusCode = GetNullableObject(dict, @"statusCode");
  NSAssert(pigeonResult.statusCode != nil, @"");
  pigeonResult.httpMsg = GetNullableObject(dict, @"httpMsg");
  pigeonResult.requestId = GetNullableObject(dict, @"requestId");
  pigeonResult.errorCode = GetNullableObject(dict, @"errorCode");
  pigeonResult.errorMessage = GetNullableObject(dict, @"errorMessage");
  pigeonResult.serviceName = GetNullableObject(dict, @"serviceName");
  pigeonResult.details = GetNullableObject(dict, @"details");
  return pigeonResult;
}
+ (nullable CosXmlServiceException *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [CosXmlServiceException fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"statusCode" : (self.statusCode ?: [NSNull null]),
    @"httpMsg" : (self.httpMsg ?: [NSNull null]),
    @"requestId" : (self.requestId ?: [NSNull null]),
    @"errorCode" : (self.errorCode ?: [NSNull null]),
    @"errorMessage" : (self.errorMessage ?: [NSNull null]),
    @"serviceName" : (self.serviceName ?: [NSNull null]),
    @"details" : (self.details ?: [NSNull null]),
  };
}
@end

@implementation Owner
+ (instancetype)makeWithId:(NSString *)id
    disPlayName:(nullable NSString *)disPlayName {
  Owner* pigeonResult = [[Owner alloc] init];
  pigeonResult.id = id;
  pigeonResult.disPlayName = disPlayName;
  return pigeonResult;
}
+ (Owner *)fromMap:(NSDictionary *)dict {
  Owner *pigeonResult = [[Owner alloc] init];
  pigeonResult.id = GetNullableObject(dict, @"id");
  NSAssert(pigeonResult.id != nil, @"");
  pigeonResult.disPlayName = GetNullableObject(dict, @"disPlayName");
  return pigeonResult;
}
+ (nullable Owner *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [Owner fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"id" : (self.id ?: [NSNull null]),
    @"disPlayName" : (self.disPlayName ?: [NSNull null]),
  };
}
@end

@implementation Bucket
+ (instancetype)makeWithName:(NSString *)name
    location:(nullable NSString *)location
    createDate:(nullable NSString *)createDate
    type:(nullable NSString *)type {
  Bucket* pigeonResult = [[Bucket alloc] init];
  pigeonResult.name = name;
  pigeonResult.location = location;
  pigeonResult.createDate = createDate;
  pigeonResult.type = type;
  return pigeonResult;
}
+ (Bucket *)fromMap:(NSDictionary *)dict {
  Bucket *pigeonResult = [[Bucket alloc] init];
  pigeonResult.name = GetNullableObject(dict, @"name");
  NSAssert(pigeonResult.name != nil, @"");
  pigeonResult.location = GetNullableObject(dict, @"location");
  pigeonResult.createDate = GetNullableObject(dict, @"createDate");
  pigeonResult.type = GetNullableObject(dict, @"type");
  return pigeonResult;
}
+ (nullable Bucket *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [Bucket fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"name" : (self.name ?: [NSNull null]),
    @"location" : (self.location ?: [NSNull null]),
    @"createDate" : (self.createDate ?: [NSNull null]),
    @"type" : (self.type ?: [NSNull null]),
  };
}
@end

@implementation ListAllMyBuckets
+ (instancetype)makeWithOwner:(Owner *)owner
    buckets:(NSArray<Bucket *> *)buckets {
  ListAllMyBuckets* pigeonResult = [[ListAllMyBuckets alloc] init];
  pigeonResult.owner = owner;
  pigeonResult.buckets = buckets;
  return pigeonResult;
}
+ (ListAllMyBuckets *)fromMap:(NSDictionary *)dict {
  ListAllMyBuckets *pigeonResult = [[ListAllMyBuckets alloc] init];
  pigeonResult.owner = [Owner nullableFromMap:GetNullableObject(dict, @"owner")];
  NSAssert(pigeonResult.owner != nil, @"");
  pigeonResult.buckets = GetNullableObject(dict, @"buckets");
  NSAssert(pigeonResult.buckets != nil, @"");
  return pigeonResult;
}
+ (nullable ListAllMyBuckets *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [ListAllMyBuckets fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"owner" : (self.owner ? [self.owner toMap] : [NSNull null]),
    @"buckets" : (self.buckets ?: [NSNull null]),
  };
}
@end

@implementation CommonPrefixes
+ (instancetype)makeWithPrefix:(NSString *)prefix {
  CommonPrefixes* pigeonResult = [[CommonPrefixes alloc] init];
  pigeonResult.prefix = prefix;
  return pigeonResult;
}
+ (CommonPrefixes *)fromMap:(NSDictionary *)dict {
  CommonPrefixes *pigeonResult = [[CommonPrefixes alloc] init];
  pigeonResult.prefix = GetNullableObject(dict, @"prefix");
  NSAssert(pigeonResult.prefix != nil, @"");
  return pigeonResult;
}
+ (nullable CommonPrefixes *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [CommonPrefixes fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"prefix" : (self.prefix ?: [NSNull null]),
  };
}
@end

@implementation Content
+ (instancetype)makeWithKey:(NSString *)key
    lastModified:(NSString *)lastModified
    eTag:(NSString *)eTag
    size:(NSNumber *)size
    owner:(Owner *)owner
    storageClass:(NSString *)storageClass {
  Content* pigeonResult = [[Content alloc] init];
  pigeonResult.key = key;
  pigeonResult.lastModified = lastModified;
  pigeonResult.eTag = eTag;
  pigeonResult.size = size;
  pigeonResult.owner = owner;
  pigeonResult.storageClass = storageClass;
  return pigeonResult;
}
+ (Content *)fromMap:(NSDictionary *)dict {
  Content *pigeonResult = [[Content alloc] init];
  pigeonResult.key = GetNullableObject(dict, @"key");
  NSAssert(pigeonResult.key != nil, @"");
  pigeonResult.lastModified = GetNullableObject(dict, @"lastModified");
  NSAssert(pigeonResult.lastModified != nil, @"");
  pigeonResult.eTag = GetNullableObject(dict, @"eTag");
  NSAssert(pigeonResult.eTag != nil, @"");
  pigeonResult.size = GetNullableObject(dict, @"size");
  NSAssert(pigeonResult.size != nil, @"");
  pigeonResult.owner = [Owner nullableFromMap:GetNullableObject(dict, @"owner")];
  NSAssert(pigeonResult.owner != nil, @"");
  pigeonResult.storageClass = GetNullableObject(dict, @"storageClass");
  NSAssert(pigeonResult.storageClass != nil, @"");
  return pigeonResult;
}
+ (nullable Content *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [Content fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"key" : (self.key ?: [NSNull null]),
    @"lastModified" : (self.lastModified ?: [NSNull null]),
    @"eTag" : (self.eTag ?: [NSNull null]),
    @"size" : (self.size ?: [NSNull null]),
    @"owner" : (self.owner ? [self.owner toMap] : [NSNull null]),
    @"storageClass" : (self.storageClass ?: [NSNull null]),
  };
}
@end

@implementation BucketContents
+ (instancetype)makeWithName:(NSString *)name
    encodingType:(nullable NSString *)encodingType
    prefix:(nullable NSString *)prefix
    marker:(nullable NSString *)marker
    maxKeys:(NSNumber *)maxKeys
    isTruncated:(NSNumber *)isTruncated
    nextMarker:(nullable NSString *)nextMarker
    contentsList:(NSArray<Content *> *)contentsList
    commonPrefixesList:(NSArray<CommonPrefixes *> *)commonPrefixesList
    delimiter:(nullable NSString *)delimiter {
  BucketContents* pigeonResult = [[BucketContents alloc] init];
  pigeonResult.name = name;
  pigeonResult.encodingType = encodingType;
  pigeonResult.prefix = prefix;
  pigeonResult.marker = marker;
  pigeonResult.maxKeys = maxKeys;
  pigeonResult.isTruncated = isTruncated;
  pigeonResult.nextMarker = nextMarker;
  pigeonResult.contentsList = contentsList;
  pigeonResult.commonPrefixesList = commonPrefixesList;
  pigeonResult.delimiter = delimiter;
  return pigeonResult;
}
+ (BucketContents *)fromMap:(NSDictionary *)dict {
  BucketContents *pigeonResult = [[BucketContents alloc] init];
  pigeonResult.name = GetNullableObject(dict, @"name");
  NSAssert(pigeonResult.name != nil, @"");
  pigeonResult.encodingType = GetNullableObject(dict, @"encodingType");
  pigeonResult.prefix = GetNullableObject(dict, @"prefix");
  pigeonResult.marker = GetNullableObject(dict, @"marker");
  pigeonResult.maxKeys = GetNullableObject(dict, @"maxKeys");
  NSAssert(pigeonResult.maxKeys != nil, @"");
  pigeonResult.isTruncated = GetNullableObject(dict, @"isTruncated");
  NSAssert(pigeonResult.isTruncated != nil, @"");
  pigeonResult.nextMarker = GetNullableObject(dict, @"nextMarker");
  pigeonResult.contentsList = GetNullableObject(dict, @"contentsList");
  NSAssert(pigeonResult.contentsList != nil, @"");
  pigeonResult.commonPrefixesList = GetNullableObject(dict, @"commonPrefixesList");
  NSAssert(pigeonResult.commonPrefixesList != nil, @"");
  pigeonResult.delimiter = GetNullableObject(dict, @"delimiter");
  return pigeonResult;
}
+ (nullable BucketContents *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [BucketContents fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"name" : (self.name ?: [NSNull null]),
    @"encodingType" : (self.encodingType ?: [NSNull null]),
    @"prefix" : (self.prefix ?: [NSNull null]),
    @"marker" : (self.marker ?: [NSNull null]),
    @"maxKeys" : (self.maxKeys ?: [NSNull null]),
    @"isTruncated" : (self.isTruncated ?: [NSNull null]),
    @"nextMarker" : (self.nextMarker ?: [NSNull null]),
    @"contentsList" : (self.contentsList ?: [NSNull null]),
    @"commonPrefixesList" : (self.commonPrefixesList ?: [NSNull null]),
    @"delimiter" : (self.delimiter ?: [NSNull null]),
  };
}
@end

@interface CosApiCodecReader : FlutterStandardReader
@end
@implementation CosApiCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [CosXmlServiceConfig fromMap:[self readValue]];
    
    case 129:     
      return [TransferConfig fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface CosApiCodecWriter : FlutterStandardWriter
@end
@implementation CosApiCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[CosXmlServiceConfig class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[TransferConfig class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface CosApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation CosApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[CosApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[CosApiCodecReader alloc] initWithData:data];
}
@end


NSObject<FlutterMessageCodec> *CosApiGetCodec() {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    CosApiCodecReaderWriter *readerWriter = [[CosApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void CosApiSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<CosApi> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosApi.initWithPlainSecret"
        binaryMessenger:binaryMessenger
        codec:CosApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(initWithPlainSecretSecretId:secretKey:error:)], @"CosApi api (%@) doesn't respond to @selector(initWithPlainSecretSecretId:secretKey:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_secretId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_secretKey = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api initWithPlainSecretSecretId:arg_secretId secretKey:arg_secretKey error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosApi.initWithSessionCredential"
        binaryMessenger:binaryMessenger
        codec:CosApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(initWithSessionCredentialWithError:)], @"CosApi api (%@) doesn't respond to @selector(initWithSessionCredentialWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api initWithSessionCredentialWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosApi.setCloseBeacon"
        binaryMessenger:binaryMessenger
        codec:CosApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setCloseBeaconIsCloseBeacon:error:)], @"CosApi api (%@) doesn't respond to @selector(setCloseBeaconIsCloseBeacon:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_isCloseBeacon = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setCloseBeaconIsCloseBeacon:arg_isCloseBeacon error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosApi.registerDefaultService"
        binaryMessenger:binaryMessenger
        codec:CosApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(registerDefaultServiceConfig:error:)], @"CosApi api (%@) doesn't respond to @selector(registerDefaultServiceConfig:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        CosXmlServiceConfig *arg_config = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api registerDefaultServiceConfig:arg_config error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosApi.registerDefaultTransferManger"
        binaryMessenger:binaryMessenger
        codec:CosApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(registerDefaultTransferMangerConfig:transferConfig:error:)], @"CosApi api (%@) doesn't respond to @selector(registerDefaultTransferMangerConfig:transferConfig:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        CosXmlServiceConfig *arg_config = GetNullableObjectAtIndex(args, 0);
        TransferConfig *arg_transferConfig = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api registerDefaultTransferMangerConfig:arg_config transferConfig:arg_transferConfig error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosApi.registerService"
        binaryMessenger:binaryMessenger
        codec:CosApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(registerServiceKey:config:error:)], @"CosApi api (%@) doesn't respond to @selector(registerServiceKey:config:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_key = GetNullableObjectAtIndex(args, 0);
        CosXmlServiceConfig *arg_config = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api registerServiceKey:arg_key config:arg_config error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosApi.registerTransferManger"
        binaryMessenger:binaryMessenger
        codec:CosApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(registerTransferMangerKey:config:transferConfig:error:)], @"CosApi api (%@) doesn't respond to @selector(registerTransferMangerKey:config:transferConfig:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_key = GetNullableObjectAtIndex(args, 0);
        CosXmlServiceConfig *arg_config = GetNullableObjectAtIndex(args, 1);
        TransferConfig *arg_transferConfig = GetNullableObjectAtIndex(args, 2);
        FlutterError *error;
        [api registerTransferMangerKey:arg_key config:arg_config transferConfig:arg_transferConfig error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface CosServiceApiCodecReader : FlutterStandardReader
@end
@implementation CosServiceApiCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [Bucket fromMap:[self readValue]];
    
    case 129:     
      return [BucketContents fromMap:[self readValue]];
    
    case 130:     
      return [CommonPrefixes fromMap:[self readValue]];
    
    case 131:     
      return [Content fromMap:[self readValue]];
    
    case 132:     
      return [ListAllMyBuckets fromMap:[self readValue]];
    
    case 133:     
      return [Owner fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface CosServiceApiCodecWriter : FlutterStandardWriter
@end
@implementation CosServiceApiCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[Bucket class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[BucketContents class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[CommonPrefixes class]]) {
    [self writeByte:130];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[Content class]]) {
    [self writeByte:131];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[ListAllMyBuckets class]]) {
    [self writeByte:132];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[Owner class]]) {
    [self writeByte:133];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface CosServiceApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation CosServiceApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[CosServiceApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[CosServiceApiCodecReader alloc] initWithData:data];
}
@end


NSObject<FlutterMessageCodec> *CosServiceApiGetCodec() {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    CosServiceApiCodecReaderWriter *readerWriter = [[CosServiceApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void CosServiceApiSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<CosServiceApi> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.headObject"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(headObjectServiceKey:bucket:region:cosPath:versionId:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(headObjectServiceKey:bucket:region:cosPath:versionId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_region = GetNullableObjectAtIndex(args, 2);
        NSString *arg_cosPath = GetNullableObjectAtIndex(args, 3);
        NSString *arg_versionId = GetNullableObjectAtIndex(args, 4);
        [api headObjectServiceKey:arg_serviceKey bucket:arg_bucket region:arg_region cosPath:arg_cosPath versionId:arg_versionId completion:^(NSDictionary<NSString *, NSString *> *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.deleteObject"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(deleteObjectServiceKey:bucket:region:cosPath:versionId:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(deleteObjectServiceKey:bucket:region:cosPath:versionId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_region = GetNullableObjectAtIndex(args, 2);
        NSString *arg_cosPath = GetNullableObjectAtIndex(args, 3);
        NSString *arg_versionId = GetNullableObjectAtIndex(args, 4);
        [api deleteObjectServiceKey:arg_serviceKey bucket:arg_bucket region:arg_region cosPath:arg_cosPath versionId:arg_versionId completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.getObjectUrl"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getObjectUrlBucket:region:key:serviceKey:error:)], @"CosServiceApi api (%@) doesn't respond to @selector(getObjectUrlBucket:region:key:serviceKey:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 0);
        NSString *arg_region = GetNullableObjectAtIndex(args, 1);
        NSString *arg_key = GetNullableObjectAtIndex(args, 2);
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 3);
        FlutterError *error;
        NSString *output = [api getObjectUrlBucket:arg_bucket region:arg_region key:arg_key serviceKey:arg_serviceKey error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.preBuildConnection"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(preBuildConnectionBucket:serviceKey:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(preBuildConnectionBucket:serviceKey:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 0);
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 1);
        [api preBuildConnectionBucket:arg_bucket serviceKey:arg_serviceKey completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.getService"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getServiceServiceKey:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(getServiceServiceKey:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        [api getServiceServiceKey:arg_serviceKey completion:^(ListAllMyBuckets *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.getBucket"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getBucketServiceKey:bucket:region:prefix:delimiter:encodingType:marker:maxKeys:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(getBucketServiceKey:bucket:region:prefix:delimiter:encodingType:marker:maxKeys:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_region = GetNullableObjectAtIndex(args, 2);
        NSString *arg_prefix = GetNullableObjectAtIndex(args, 3);
        NSString *arg_delimiter = GetNullableObjectAtIndex(args, 4);
        NSString *arg_encodingType = GetNullableObjectAtIndex(args, 5);
        NSString *arg_marker = GetNullableObjectAtIndex(args, 6);
        NSNumber *arg_maxKeys = GetNullableObjectAtIndex(args, 7);
        [api getBucketServiceKey:arg_serviceKey bucket:arg_bucket region:arg_region prefix:arg_prefix delimiter:arg_delimiter encodingType:arg_encodingType marker:arg_marker maxKeys:arg_maxKeys completion:^(BucketContents *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.putBucket"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(putBucketServiceKey:bucket:region:enableMAZ:cosacl:readAccount:writeAccount:readWriteAccount:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(putBucketServiceKey:bucket:region:enableMAZ:cosacl:readAccount:writeAccount:readWriteAccount:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_region = GetNullableObjectAtIndex(args, 2);
        NSNumber *arg_enableMAZ = GetNullableObjectAtIndex(args, 3);
        NSString *arg_cosacl = GetNullableObjectAtIndex(args, 4);
        NSString *arg_readAccount = GetNullableObjectAtIndex(args, 5);
        NSString *arg_writeAccount = GetNullableObjectAtIndex(args, 6);
        NSString *arg_readWriteAccount = GetNullableObjectAtIndex(args, 7);
        [api putBucketServiceKey:arg_serviceKey bucket:arg_bucket region:arg_region enableMAZ:arg_enableMAZ cosacl:arg_cosacl readAccount:arg_readAccount writeAccount:arg_writeAccount readWriteAccount:arg_readWriteAccount completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.headBucket"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(headBucketServiceKey:bucket:region:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(headBucketServiceKey:bucket:region:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_region = GetNullableObjectAtIndex(args, 2);
        [api headBucketServiceKey:arg_serviceKey bucket:arg_bucket region:arg_region completion:^(NSDictionary<NSString *, NSString *> *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.deleteBucket"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(deleteBucketServiceKey:bucket:region:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(deleteBucketServiceKey:bucket:region:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_region = GetNullableObjectAtIndex(args, 2);
        [api deleteBucketServiceKey:arg_serviceKey bucket:arg_bucket region:arg_region completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.getBucketAccelerate"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getBucketAccelerateServiceKey:bucket:region:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(getBucketAccelerateServiceKey:bucket:region:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_region = GetNullableObjectAtIndex(args, 2);
        [api getBucketAccelerateServiceKey:arg_serviceKey bucket:arg_bucket region:arg_region completion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.putBucketAccelerate"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(putBucketAccelerateServiceKey:bucket:region:enable:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(putBucketAccelerateServiceKey:bucket:region:enable:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_region = GetNullableObjectAtIndex(args, 2);
        NSNumber *arg_enable = GetNullableObjectAtIndex(args, 3);
        [api putBucketAccelerateServiceKey:arg_serviceKey bucket:arg_bucket region:arg_region enable:arg_enable completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.getBucketLocation"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getBucketLocationServiceKey:bucket:region:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(getBucketLocationServiceKey:bucket:region:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_region = GetNullableObjectAtIndex(args, 2);
        [api getBucketLocationServiceKey:arg_serviceKey bucket:arg_bucket region:arg_region completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.getBucketVersioning"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getBucketVersioningServiceKey:bucket:region:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(getBucketVersioningServiceKey:bucket:region:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_region = GetNullableObjectAtIndex(args, 2);
        [api getBucketVersioningServiceKey:arg_serviceKey bucket:arg_bucket region:arg_region completion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.putBucketVersioning"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(putBucketVersioningServiceKey:bucket:region:enable:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(putBucketVersioningServiceKey:bucket:region:enable:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_region = GetNullableObjectAtIndex(args, 2);
        NSNumber *arg_enable = GetNullableObjectAtIndex(args, 3);
        [api putBucketVersioningServiceKey:arg_serviceKey bucket:arg_bucket region:arg_region enable:arg_enable completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.doesBucketExist"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(doesBucketExistServiceKey:bucket:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(doesBucketExistServiceKey:bucket:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        [api doesBucketExistServiceKey:arg_serviceKey bucket:arg_bucket completion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.doesObjectExist"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(doesObjectExistServiceKey:bucket:cosPath:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(doesObjectExistServiceKey:bucket:cosPath:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_cosPath = GetNullableObjectAtIndex(args, 2);
        [api doesObjectExistServiceKey:arg_serviceKey bucket:arg_bucket cosPath:arg_cosPath completion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.cancelAll"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cancelAllServiceKey:error:)], @"CosServiceApi api (%@) doesn't respond to @selector(cancelAllServiceKey:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api cancelAllServiceKey:arg_serviceKey error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
NSObject<FlutterMessageCodec> *CosTransferApiGetCodec() {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  sSharedObject = [FlutterStandardMessageCodec sharedInstance];
  return sSharedObject;
}

void CosTransferApiSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<CosTransferApi> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosTransferApi.upload"
        binaryMessenger:binaryMessenger
        codec:CosTransferApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(uploadTransferKey:bucket:cosPath:region:filePath:byteArr:uploadId:stroageClass:trafficLimit:resultCallbackKey:stateCallbackKey:progressCallbackKey:initMultipleUploadCallbackKey:error:)], @"CosTransferApi api (%@) doesn't respond to @selector(uploadTransferKey:bucket:cosPath:region:filePath:byteArr:uploadId:stroageClass:trafficLimit:resultCallbackKey:stateCallbackKey:progressCallbackKey:initMultipleUploadCallbackKey:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_transferKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_cosPath = GetNullableObjectAtIndex(args, 2);
        NSString *arg_region = GetNullableObjectAtIndex(args, 3);
        NSString *arg_filePath = GetNullableObjectAtIndex(args, 4);
        FlutterStandardTypedData *arg_byteArr = GetNullableObjectAtIndex(args, 5);
        NSString *arg_uploadId = GetNullableObjectAtIndex(args, 6);
        NSString *arg_stroageClass = GetNullableObjectAtIndex(args, 7);
        NSNumber *arg_trafficLimit = GetNullableObjectAtIndex(args, 8);
        NSNumber *arg_resultCallbackKey = GetNullableObjectAtIndex(args, 9);
        NSNumber *arg_stateCallbackKey = GetNullableObjectAtIndex(args, 10);
        NSNumber *arg_progressCallbackKey = GetNullableObjectAtIndex(args, 11);
        NSNumber *arg_initMultipleUploadCallbackKey = GetNullableObjectAtIndex(args, 12);
        FlutterError *error;
        NSString *output = [api uploadTransferKey:arg_transferKey bucket:arg_bucket cosPath:arg_cosPath region:arg_region filePath:arg_filePath byteArr:arg_byteArr uploadId:arg_uploadId stroageClass:arg_stroageClass trafficLimit:arg_trafficLimit resultCallbackKey:arg_resultCallbackKey stateCallbackKey:arg_stateCallbackKey progressCallbackKey:arg_progressCallbackKey initMultipleUploadCallbackKey:arg_initMultipleUploadCallbackKey error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosTransferApi.download"
        binaryMessenger:binaryMessenger
        codec:CosTransferApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(downloadTransferKey:bucket:cosPath:region:savePath:versionId:trafficLimit:resultCallbackKey:stateCallbackKey:progressCallbackKey:error:)], @"CosTransferApi api (%@) doesn't respond to @selector(downloadTransferKey:bucket:cosPath:region:savePath:versionId:trafficLimit:resultCallbackKey:stateCallbackKey:progressCallbackKey:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_transferKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_cosPath = GetNullableObjectAtIndex(args, 2);
        NSString *arg_region = GetNullableObjectAtIndex(args, 3);
        NSString *arg_savePath = GetNullableObjectAtIndex(args, 4);
        NSString *arg_versionId = GetNullableObjectAtIndex(args, 5);
        NSNumber *arg_trafficLimit = GetNullableObjectAtIndex(args, 6);
        NSNumber *arg_resultCallbackKey = GetNullableObjectAtIndex(args, 7);
        NSNumber *arg_stateCallbackKey = GetNullableObjectAtIndex(args, 8);
        NSNumber *arg_progressCallbackKey = GetNullableObjectAtIndex(args, 9);
        FlutterError *error;
        NSString *output = [api downloadTransferKey:arg_transferKey bucket:arg_bucket cosPath:arg_cosPath region:arg_region savePath:arg_savePath versionId:arg_versionId trafficLimit:arg_trafficLimit resultCallbackKey:arg_resultCallbackKey stateCallbackKey:arg_stateCallbackKey progressCallbackKey:arg_progressCallbackKey error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosTransferApi.pause"
        binaryMessenger:binaryMessenger
        codec:CosTransferApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(pauseTaskId:transferKey:error:)], @"CosTransferApi api (%@) doesn't respond to @selector(pauseTaskId:transferKey:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_taskId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_transferKey = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api pauseTaskId:arg_taskId transferKey:arg_transferKey error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosTransferApi.resume"
        binaryMessenger:binaryMessenger
        codec:CosTransferApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(resumeTaskId:transferKey:error:)], @"CosTransferApi api (%@) doesn't respond to @selector(resumeTaskId:transferKey:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_taskId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_transferKey = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api resumeTaskId:arg_taskId transferKey:arg_transferKey error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosTransferApi.cancel"
        binaryMessenger:binaryMessenger
        codec:CosTransferApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cancelTaskId:transferKey:error:)], @"CosTransferApi api (%@) doesn't respond to @selector(cancelTaskId:transferKey:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_taskId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_transferKey = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api cancelTaskId:arg_taskId transferKey:arg_transferKey error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FlutterCosApiCodecReader : FlutterStandardReader
@end
@implementation FlutterCosApiCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [CosXmlClientException fromMap:[self readValue]];
    
    case 129:     
      return [CosXmlServiceException fromMap:[self readValue]];
    
    case 130:     
      return [SessionQCloudCredentials fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface FlutterCosApiCodecWriter : FlutterStandardWriter
@end
@implementation FlutterCosApiCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[CosXmlClientException class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[CosXmlServiceException class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[SessionQCloudCredentials class]]) {
    [self writeByte:130];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface FlutterCosApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FlutterCosApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FlutterCosApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FlutterCosApiCodecReader alloc] initWithData:data];
}
@end


NSObject<FlutterMessageCodec> *FlutterCosApiGetCodec() {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FlutterCosApiCodecReaderWriter *readerWriter = [[FlutterCosApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

@interface FlutterCosApi ()
@property (nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation FlutterCosApi

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)fetchSessionCredentialsWithCompletion:(void(^)(SessionQCloudCredentials *_Nullable, NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.FlutterCosApi.fetchSessionCredentials"
      binaryMessenger:self.binaryMessenger
      codec:FlutterCosApiGetCodec()      ];  [channel sendMessage:nil reply:^(id reply) {
    SessionQCloudCredentials *output = reply;
    completion(output, nil);
  }];
}
- (void)resultSuccessCallbackTransferKey:(NSString *)arg_transferKey key:(NSNumber *)arg_key header:(nullable NSDictionary<NSString *, NSString *> *)arg_header completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.FlutterCosApi.resultSuccessCallback"
      binaryMessenger:self.binaryMessenger
      codec:FlutterCosApiGetCodec()      ];  [channel sendMessage:@[arg_transferKey ?: [NSNull null], arg_key ?: [NSNull null], arg_header ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
- (void)resultFailCallbackTransferKey:(NSString *)arg_transferKey key:(NSNumber *)arg_key clientException:(nullable CosXmlClientException *)arg_clientException serviceException:(nullable CosXmlServiceException *)arg_serviceException completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.FlutterCosApi.resultFailCallback"
      binaryMessenger:self.binaryMessenger
      codec:FlutterCosApiGetCodec()      ];  [channel sendMessage:@[arg_transferKey ?: [NSNull null], arg_key ?: [NSNull null], arg_clientException ?: [NSNull null], arg_serviceException ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
- (void)stateCallbackTransferKey:(NSString *)arg_transferKey key:(NSNumber *)arg_key state:(NSString *)arg_state completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.FlutterCosApi.stateCallback"
      binaryMessenger:self.binaryMessenger
      codec:FlutterCosApiGetCodec()      ];  [channel sendMessage:@[arg_transferKey ?: [NSNull null], arg_key ?: [NSNull null], arg_state ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
- (void)progressCallbackTransferKey:(NSString *)arg_transferKey key:(NSNumber *)arg_key complete:(NSNumber *)arg_complete target:(NSNumber *)arg_target completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.FlutterCosApi.progressCallback"
      binaryMessenger:self.binaryMessenger
      codec:FlutterCosApiGetCodec()      ];  [channel sendMessage:@[arg_transferKey ?: [NSNull null], arg_key ?: [NSNull null], arg_complete ?: [NSNull null], arg_target ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
- (void)initMultipleUploadCallbackTransferKey:(NSString *)arg_transferKey key:(NSNumber *)arg_key bucket:(NSString *)arg_bucket cosKey:(NSString *)arg_cosKey uploadId:(NSString *)arg_uploadId completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.FlutterCosApi.initMultipleUploadCallback"
      binaryMessenger:self.binaryMessenger
      codec:FlutterCosApiGetCodec()      ];  [channel sendMessage:@[arg_transferKey ?: [NSNull null], arg_key ?: [NSNull null], arg_bucket ?: [NSNull null], arg_cosKey ?: [NSNull null], arg_uploadId ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
@end
