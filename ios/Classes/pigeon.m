// Autogenerated from Pigeon (v4.2.14), do not edit directly.
// See also: https://pub.dev/packages/pigeon
#import "pigeon.h"
#import <Flutter/Flutter.h>

#if !__has_feature(objc_arc)
#error File requires ARC to be enabled.
#endif

static NSArray *wrapResult(id result, FlutterError *error) {
  if (error) {
    return @[ error.code ?: [NSNull null], error.message ?: [NSNull null], error.details ?: [NSNull null] ];
  }
  return @[ result ?: [NSNull null]  ];
}
static id GetNullableObject(NSDictionary* dict, id key) {
  id result = dict[key];
  return (result == [NSNull null]) ? nil : result;
}
static id GetNullableObjectAtIndex(NSArray* array, NSInteger key) {
  id result = array[key];
  return (result == [NSNull null]) ? nil : result;
}


@interface CosXmlServiceConfig ()
+ (CosXmlServiceConfig *)fromList:(NSArray *)list;
+ (nullable CosXmlServiceConfig *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end
@interface TransferConfig ()
+ (TransferConfig *)fromList:(NSArray *)list;
+ (nullable TransferConfig *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end
@interface SessionQCloudCredentials ()
+ (SessionQCloudCredentials *)fromList:(NSArray *)list;
+ (nullable SessionQCloudCredentials *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end
@interface CosXmlClientException ()
+ (CosXmlClientException *)fromList:(NSArray *)list;
+ (nullable CosXmlClientException *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end
@interface CosXmlServiceException ()
+ (CosXmlServiceException *)fromList:(NSArray *)list;
+ (nullable CosXmlServiceException *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end
@interface Owner ()
+ (Owner *)fromList:(NSArray *)list;
+ (nullable Owner *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end
@interface Bucket ()
+ (Bucket *)fromList:(NSArray *)list;
+ (nullable Bucket *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end
@interface ListAllMyBuckets ()
+ (ListAllMyBuckets *)fromList:(NSArray *)list;
+ (nullable ListAllMyBuckets *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end
@interface CommonPrefixes ()
+ (CommonPrefixes *)fromList:(NSArray *)list;
+ (nullable CommonPrefixes *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end
@interface Content ()
+ (Content *)fromList:(NSArray *)list;
+ (nullable Content *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end
@interface BucketContents ()
+ (BucketContents *)fromList:(NSArray *)list;
+ (nullable BucketContents *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@implementation CosXmlServiceConfig
+ (instancetype)makeWithRegion:(nullable NSString *)region
    connectionTimeout:(nullable NSNumber *)connectionTimeout
    socketTimeout:(nullable NSNumber *)socketTimeout
    isHttps:(nullable NSNumber *)isHttps
    host:(nullable NSString *)host
    hostFormat:(nullable NSString *)hostFormat
    port:(nullable NSNumber *)port
    isDebuggable:(nullable NSNumber *)isDebuggable
    signInUrl:(nullable NSNumber *)signInUrl
    userAgent:(nullable NSString *)userAgent
    dnsCache:(nullable NSNumber *)dnsCache
    accelerate:(nullable NSNumber *)accelerate {
  CosXmlServiceConfig* pigeonResult = [[CosXmlServiceConfig alloc] init];
  pigeonResult.region = region;
  pigeonResult.connectionTimeout = connectionTimeout;
  pigeonResult.socketTimeout = socketTimeout;
  pigeonResult.isHttps = isHttps;
  pigeonResult.host = host;
  pigeonResult.hostFormat = hostFormat;
  pigeonResult.port = port;
  pigeonResult.isDebuggable = isDebuggable;
  pigeonResult.signInUrl = signInUrl;
  pigeonResult.userAgent = userAgent;
  pigeonResult.dnsCache = dnsCache;
  pigeonResult.accelerate = accelerate;
  return pigeonResult;
}
+ (CosXmlServiceConfig *)fromList:(NSArray *)list {
  CosXmlServiceConfig *pigeonResult = [[CosXmlServiceConfig alloc] init];
  pigeonResult.region = GetNullableObjectAtIndex(list, 0);
  pigeonResult.connectionTimeout = GetNullableObjectAtIndex(list, 1);
  pigeonResult.socketTimeout = GetNullableObjectAtIndex(list, 2);
  pigeonResult.isHttps = GetNullableObjectAtIndex(list, 3);
  pigeonResult.host = GetNullableObjectAtIndex(list, 4);
  pigeonResult.hostFormat = GetNullableObjectAtIndex(list, 5);
  pigeonResult.port = GetNullableObjectAtIndex(list, 6);
  pigeonResult.isDebuggable = GetNullableObjectAtIndex(list, 7);
  pigeonResult.signInUrl = GetNullableObjectAtIndex(list, 8);
  pigeonResult.userAgent = GetNullableObjectAtIndex(list, 9);
  pigeonResult.dnsCache = GetNullableObjectAtIndex(list, 10);
  pigeonResult.accelerate = GetNullableObjectAtIndex(list, 11);
  return pigeonResult;
}
+ (nullable CosXmlServiceConfig *)nullableFromList:(NSArray *)list { return (list) ? [CosXmlServiceConfig fromList:list] : nil; }
- (NSArray *)toList {
  return @[
    (self.region ?: [NSNull null]),
    (self.connectionTimeout ?: [NSNull null]),
    (self.socketTimeout ?: [NSNull null]),
    (self.isHttps ?: [NSNull null]),
    (self.host ?: [NSNull null]),
    (self.hostFormat ?: [NSNull null]),
    (self.port ?: [NSNull null]),
    (self.isDebuggable ?: [NSNull null]),
    (self.signInUrl ?: [NSNull null]),
    (self.userAgent ?: [NSNull null]),
    (self.dnsCache ?: [NSNull null]),
    (self.accelerate ?: [NSNull null]),
  ];
}
@end

@implementation TransferConfig
+ (instancetype)makeWithForceSimpleUpload:(nullable NSNumber *)forceSimpleUpload
    enableVerification:(nullable NSNumber *)enableVerification
    divisionForUpload:(nullable NSNumber *)divisionForUpload
    sliceSizeForUpload:(nullable NSNumber *)sliceSizeForUpload {
  TransferConfig* pigeonResult = [[TransferConfig alloc] init];
  pigeonResult.forceSimpleUpload = forceSimpleUpload;
  pigeonResult.enableVerification = enableVerification;
  pigeonResult.divisionForUpload = divisionForUpload;
  pigeonResult.sliceSizeForUpload = sliceSizeForUpload;
  return pigeonResult;
}
+ (TransferConfig *)fromList:(NSArray *)list {
  TransferConfig *pigeonResult = [[TransferConfig alloc] init];
  pigeonResult.forceSimpleUpload = GetNullableObjectAtIndex(list, 0);
  pigeonResult.enableVerification = GetNullableObjectAtIndex(list, 1);
  pigeonResult.divisionForUpload = GetNullableObjectAtIndex(list, 2);
  pigeonResult.sliceSizeForUpload = GetNullableObjectAtIndex(list, 3);
  return pigeonResult;
}
+ (nullable TransferConfig *)nullableFromList:(NSArray *)list { return (list) ? [TransferConfig fromList:list] : nil; }
- (NSArray *)toList {
  return @[
    (self.forceSimpleUpload ?: [NSNull null]),
    (self.enableVerification ?: [NSNull null]),
    (self.divisionForUpload ?: [NSNull null]),
    (self.sliceSizeForUpload ?: [NSNull null]),
  ];
}
@end

@implementation SessionQCloudCredentials
+ (instancetype)makeWithSecretId:(NSString *)secretId
    secretKey:(NSString *)secretKey
    token:(NSString *)token
    startTime:(nullable NSNumber *)startTime
    expiredTime:(NSNumber *)expiredTime {
  SessionQCloudCredentials* pigeonResult = [[SessionQCloudCredentials alloc] init];
  pigeonResult.secretId = secretId;
  pigeonResult.secretKey = secretKey;
  pigeonResult.token = token;
  pigeonResult.startTime = startTime;
  pigeonResult.expiredTime = expiredTime;
  return pigeonResult;
}
+ (SessionQCloudCredentials *)fromList:(NSArray *)list {
  SessionQCloudCredentials *pigeonResult = [[SessionQCloudCredentials alloc] init];
  pigeonResult.secretId = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.secretId != nil, @"");
  pigeonResult.secretKey = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.secretKey != nil, @"");
  pigeonResult.token = GetNullableObjectAtIndex(list, 2);
  NSAssert(pigeonResult.token != nil, @"");
  pigeonResult.startTime = GetNullableObjectAtIndex(list, 3);
  pigeonResult.expiredTime = GetNullableObjectAtIndex(list, 4);
  NSAssert(pigeonResult.expiredTime != nil, @"");
  return pigeonResult;
}
+ (nullable SessionQCloudCredentials *)nullableFromList:(NSArray *)list { return (list) ? [SessionQCloudCredentials fromList:list] : nil; }
- (NSArray *)toList {
  return @[
    (self.secretId ?: [NSNull null]),
    (self.secretKey ?: [NSNull null]),
    (self.token ?: [NSNull null]),
    (self.startTime ?: [NSNull null]),
    (self.expiredTime ?: [NSNull null]),
  ];
}
@end

@implementation CosXmlClientException
+ (instancetype)makeWithErrorCode:(NSNumber *)errorCode
    message:(nullable NSString *)message
    details:(nullable NSString *)details {
  CosXmlClientException* pigeonResult = [[CosXmlClientException alloc] init];
  pigeonResult.errorCode = errorCode;
  pigeonResult.message = message;
  pigeonResult.details = details;
  return pigeonResult;
}
+ (CosXmlClientException *)fromList:(NSArray *)list {
  CosXmlClientException *pigeonResult = [[CosXmlClientException alloc] init];
  pigeonResult.errorCode = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.errorCode != nil, @"");
  pigeonResult.message = GetNullableObjectAtIndex(list, 1);
  pigeonResult.details = GetNullableObjectAtIndex(list, 2);
  return pigeonResult;
}
+ (nullable CosXmlClientException *)nullableFromList:(NSArray *)list { return (list) ? [CosXmlClientException fromList:list] : nil; }
- (NSArray *)toList {
  return @[
    (self.errorCode ?: [NSNull null]),
    (self.message ?: [NSNull null]),
    (self.details ?: [NSNull null]),
  ];
}
@end

@implementation CosXmlServiceException
+ (instancetype)makeWithStatusCode:(NSNumber *)statusCode
    httpMsg:(nullable NSString *)httpMsg
    requestId:(nullable NSString *)requestId
    errorCode:(nullable NSString *)errorCode
    errorMessage:(nullable NSString *)errorMessage
    serviceName:(nullable NSString *)serviceName
    details:(nullable NSString *)details {
  CosXmlServiceException* pigeonResult = [[CosXmlServiceException alloc] init];
  pigeonResult.statusCode = statusCode;
  pigeonResult.httpMsg = httpMsg;
  pigeonResult.requestId = requestId;
  pigeonResult.errorCode = errorCode;
  pigeonResult.errorMessage = errorMessage;
  pigeonResult.serviceName = serviceName;
  pigeonResult.details = details;
  return pigeonResult;
}
+ (CosXmlServiceException *)fromList:(NSArray *)list {
  CosXmlServiceException *pigeonResult = [[CosXmlServiceException alloc] init];
  pigeonResult.statusCode = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.statusCode != nil, @"");
  pigeonResult.httpMsg = GetNullableObjectAtIndex(list, 1);
  pigeonResult.requestId = GetNullableObjectAtIndex(list, 2);
  pigeonResult.errorCode = GetNullableObjectAtIndex(list, 3);
  pigeonResult.errorMessage = GetNullableObjectAtIndex(list, 4);
  pigeonResult.serviceName = GetNullableObjectAtIndex(list, 5);
  pigeonResult.details = GetNullableObjectAtIndex(list, 6);
  return pigeonResult;
}
+ (nullable CosXmlServiceException *)nullableFromList:(NSArray *)list { return (list) ? [CosXmlServiceException fromList:list] : nil; }
- (NSArray *)toList {
  return @[
    (self.statusCode ?: [NSNull null]),
    (self.httpMsg ?: [NSNull null]),
    (self.requestId ?: [NSNull null]),
    (self.errorCode ?: [NSNull null]),
    (self.errorMessage ?: [NSNull null]),
    (self.serviceName ?: [NSNull null]),
    (self.details ?: [NSNull null]),
  ];
}
@end

@implementation Owner
+ (instancetype)makeWithId:(NSString *)id
    disPlayName:(nullable NSString *)disPlayName {
  Owner* pigeonResult = [[Owner alloc] init];
  pigeonResult.id = id;
  pigeonResult.disPlayName = disPlayName;
  return pigeonResult;
}
+ (Owner *)fromList:(NSArray *)list {
  Owner *pigeonResult = [[Owner alloc] init];
  pigeonResult.id = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.id != nil, @"");
  pigeonResult.disPlayName = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable Owner *)nullableFromList:(NSArray *)list { return (list) ? [Owner fromList:list] : nil; }
- (NSArray *)toList {
  return @[
    (self.id ?: [NSNull null]),
    (self.disPlayName ?: [NSNull null]),
  ];
}
@end

@implementation Bucket
+ (instancetype)makeWithName:(NSString *)name
    location:(nullable NSString *)location
    createDate:(nullable NSString *)createDate
    type:(nullable NSString *)type {
  Bucket* pigeonResult = [[Bucket alloc] init];
  pigeonResult.name = name;
  pigeonResult.location = location;
  pigeonResult.createDate = createDate;
  pigeonResult.type = type;
  return pigeonResult;
}
+ (Bucket *)fromList:(NSArray *)list {
  Bucket *pigeonResult = [[Bucket alloc] init];
  pigeonResult.name = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.name != nil, @"");
  pigeonResult.location = GetNullableObjectAtIndex(list, 1);
  pigeonResult.createDate = GetNullableObjectAtIndex(list, 2);
  pigeonResult.type = GetNullableObjectAtIndex(list, 3);
  return pigeonResult;
}
+ (nullable Bucket *)nullableFromList:(NSArray *)list { return (list) ? [Bucket fromList:list] : nil; }
- (NSArray *)toList {
  return @[
    (self.name ?: [NSNull null]),
    (self.location ?: [NSNull null]),
    (self.createDate ?: [NSNull null]),
    (self.type ?: [NSNull null]),
  ];
}
@end

@implementation ListAllMyBuckets
+ (instancetype)makeWithOwner:(Owner *)owner
    buckets:(NSArray<Bucket *> *)buckets {
  ListAllMyBuckets* pigeonResult = [[ListAllMyBuckets alloc] init];
  pigeonResult.owner = owner;
  pigeonResult.buckets = buckets;
  return pigeonResult;
}
+ (ListAllMyBuckets *)fromList:(NSArray *)list {
  ListAllMyBuckets *pigeonResult = [[ListAllMyBuckets alloc] init];
  pigeonResult.owner = [Owner nullableFromList:(GetNullableObjectAtIndex(list, 0))];
  NSAssert(pigeonResult.owner != nil, @"");
  pigeonResult.buckets = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.buckets != nil, @"");
  return pigeonResult;
}
+ (nullable ListAllMyBuckets *)nullableFromList:(NSArray *)list { return (list) ? [ListAllMyBuckets fromList:list] : nil; }
- (NSArray *)toList {
  return @[
    (self.owner ? [self.owner toList] : [NSNull null]),
    (self.buckets ?: [NSNull null]),
  ];
}
@end

@implementation CommonPrefixes
+ (instancetype)makeWithPrefix:(NSString *)prefix {
  CommonPrefixes* pigeonResult = [[CommonPrefixes alloc] init];
  pigeonResult.prefix = prefix;
  return pigeonResult;
}
+ (CommonPrefixes *)fromList:(NSArray *)list {
  CommonPrefixes *pigeonResult = [[CommonPrefixes alloc] init];
  pigeonResult.prefix = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.prefix != nil, @"");
  return pigeonResult;
}
+ (nullable CommonPrefixes *)nullableFromList:(NSArray *)list { return (list) ? [CommonPrefixes fromList:list] : nil; }
- (NSArray *)toList {
  return @[
    (self.prefix ?: [NSNull null]),
  ];
}
@end

@implementation Content
+ (instancetype)makeWithKey:(NSString *)key
    lastModified:(NSString *)lastModified
    eTag:(NSString *)eTag
    size:(NSNumber *)size
    owner:(Owner *)owner
    storageClass:(NSString *)storageClass {
  Content* pigeonResult = [[Content alloc] init];
  pigeonResult.key = key;
  pigeonResult.lastModified = lastModified;
  pigeonResult.eTag = eTag;
  pigeonResult.size = size;
  pigeonResult.owner = owner;
  pigeonResult.storageClass = storageClass;
  return pigeonResult;
}
+ (Content *)fromList:(NSArray *)list {
  Content *pigeonResult = [[Content alloc] init];
  pigeonResult.key = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.key != nil, @"");
  pigeonResult.lastModified = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.lastModified != nil, @"");
  pigeonResult.eTag = GetNullableObjectAtIndex(list, 2);
  NSAssert(pigeonResult.eTag != nil, @"");
  pigeonResult.size = GetNullableObjectAtIndex(list, 3);
  NSAssert(pigeonResult.size != nil, @"");
  pigeonResult.owner = [Owner nullableFromList:(GetNullableObjectAtIndex(list, 4))];
  NSAssert(pigeonResult.owner != nil, @"");
  pigeonResult.storageClass = GetNullableObjectAtIndex(list, 5);
  NSAssert(pigeonResult.storageClass != nil, @"");
  return pigeonResult;
}
+ (nullable Content *)nullableFromList:(NSArray *)list { return (list) ? [Content fromList:list] : nil; }
- (NSArray *)toList {
  return @[
    (self.key ?: [NSNull null]),
    (self.lastModified ?: [NSNull null]),
    (self.eTag ?: [NSNull null]),
    (self.size ?: [NSNull null]),
    (self.owner ? [self.owner toList] : [NSNull null]),
    (self.storageClass ?: [NSNull null]),
  ];
}
@end

@implementation BucketContents
+ (instancetype)makeWithName:(NSString *)name
    encodingType:(nullable NSString *)encodingType
    prefix:(nullable NSString *)prefix
    marker:(nullable NSString *)marker
    maxKeys:(NSNumber *)maxKeys
    isTruncated:(NSNumber *)isTruncated
    nextMarker:(nullable NSString *)nextMarker
    contentsList:(NSArray<Content *> *)contentsList
    commonPrefixesList:(NSArray<CommonPrefixes *> *)commonPrefixesList
    delimiter:(nullable NSString *)delimiter {
  BucketContents* pigeonResult = [[BucketContents alloc] init];
  pigeonResult.name = name;
  pigeonResult.encodingType = encodingType;
  pigeonResult.prefix = prefix;
  pigeonResult.marker = marker;
  pigeonResult.maxKeys = maxKeys;
  pigeonResult.isTruncated = isTruncated;
  pigeonResult.nextMarker = nextMarker;
  pigeonResult.contentsList = contentsList;
  pigeonResult.commonPrefixesList = commonPrefixesList;
  pigeonResult.delimiter = delimiter;
  return pigeonResult;
}
+ (BucketContents *)fromList:(NSArray *)list {
  BucketContents *pigeonResult = [[BucketContents alloc] init];
  pigeonResult.name = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.name != nil, @"");
  pigeonResult.encodingType = GetNullableObjectAtIndex(list, 1);
  pigeonResult.prefix = GetNullableObjectAtIndex(list, 2);
  pigeonResult.marker = GetNullableObjectAtIndex(list, 3);
  pigeonResult.maxKeys = GetNullableObjectAtIndex(list, 4);
  NSAssert(pigeonResult.maxKeys != nil, @"");
  pigeonResult.isTruncated = GetNullableObjectAtIndex(list, 5);
  NSAssert(pigeonResult.isTruncated != nil, @"");
  pigeonResult.nextMarker = GetNullableObjectAtIndex(list, 6);
  pigeonResult.contentsList = GetNullableObjectAtIndex(list, 7);
  NSAssert(pigeonResult.contentsList != nil, @"");
  pigeonResult.commonPrefixesList = GetNullableObjectAtIndex(list, 8);
  NSAssert(pigeonResult.commonPrefixesList != nil, @"");
  pigeonResult.delimiter = GetNullableObjectAtIndex(list, 9);
  return pigeonResult;
}
+ (nullable BucketContents *)nullableFromList:(NSArray *)list { return (list) ? [BucketContents fromList:list] : nil; }
- (NSArray *)toList {
  return @[
    (self.name ?: [NSNull null]),
    (self.encodingType ?: [NSNull null]),
    (self.prefix ?: [NSNull null]),
    (self.marker ?: [NSNull null]),
    (self.maxKeys ?: [NSNull null]),
    (self.isTruncated ?: [NSNull null]),
    (self.nextMarker ?: [NSNull null]),
    (self.contentsList ?: [NSNull null]),
    (self.commonPrefixesList ?: [NSNull null]),
    (self.delimiter ?: [NSNull null]),
  ];
}
@end

@interface CosApiCodecReader : FlutterStandardReader
@end
@implementation CosApiCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [CosXmlServiceConfig fromList:[self readValue]];
    
    case 129:     
      return [TransferConfig fromList:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface CosApiCodecWriter : FlutterStandardWriter
@end
@implementation CosApiCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[CosXmlServiceConfig class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else 
  if ([value isKindOfClass:[TransferConfig class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface CosApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation CosApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[CosApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[CosApiCodecReader alloc] initWithData:data];
}
@end


NSObject<FlutterMessageCodec> *CosApiGetCodec() {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    CosApiCodecReaderWriter *readerWriter = [[CosApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void CosApiSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<CosApi> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosApi.initWithPlainSecret"
        binaryMessenger:binaryMessenger
        codec:CosApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(initWithPlainSecretSecretId:secretKey:error:)], @"CosApi api (%@) doesn't respond to @selector(initWithPlainSecretSecretId:secretKey:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_secretId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_secretKey = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api initWithPlainSecretSecretId:arg_secretId secretKey:arg_secretKey error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosApi.initWithSessionCredential"
        binaryMessenger:binaryMessenger
        codec:CosApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(initWithSessionCredentialWithError:)], @"CosApi api (%@) doesn't respond to @selector(initWithSessionCredentialWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api initWithSessionCredentialWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosApi.setCloseBeacon"
        binaryMessenger:binaryMessenger
        codec:CosApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setCloseBeaconIsCloseBeacon:error:)], @"CosApi api (%@) doesn't respond to @selector(setCloseBeaconIsCloseBeacon:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_isCloseBeacon = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setCloseBeaconIsCloseBeacon:arg_isCloseBeacon error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosApi.registerDefaultService"
        binaryMessenger:binaryMessenger
        codec:CosApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(registerDefaultServiceConfig:completion:)], @"CosApi api (%@) doesn't respond to @selector(registerDefaultServiceConfig:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        CosXmlServiceConfig *arg_config = GetNullableObjectAtIndex(args, 0);
        [api registerDefaultServiceConfig:arg_config completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosApi.registerDefaultTransferManger"
        binaryMessenger:binaryMessenger
        codec:CosApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(registerDefaultTransferMangerConfig:transferConfig:completion:)], @"CosApi api (%@) doesn't respond to @selector(registerDefaultTransferMangerConfig:transferConfig:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        CosXmlServiceConfig *arg_config = GetNullableObjectAtIndex(args, 0);
        TransferConfig *arg_transferConfig = GetNullableObjectAtIndex(args, 1);
        [api registerDefaultTransferMangerConfig:arg_config transferConfig:arg_transferConfig completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosApi.registerService"
        binaryMessenger:binaryMessenger
        codec:CosApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(registerServiceKey:config:completion:)], @"CosApi api (%@) doesn't respond to @selector(registerServiceKey:config:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_key = GetNullableObjectAtIndex(args, 0);
        CosXmlServiceConfig *arg_config = GetNullableObjectAtIndex(args, 1);
        [api registerServiceKey:arg_key config:arg_config completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosApi.registerTransferManger"
        binaryMessenger:binaryMessenger
        codec:CosApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(registerTransferMangerKey:config:transferConfig:completion:)], @"CosApi api (%@) doesn't respond to @selector(registerTransferMangerKey:config:transferConfig:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_key = GetNullableObjectAtIndex(args, 0);
        CosXmlServiceConfig *arg_config = GetNullableObjectAtIndex(args, 1);
        TransferConfig *arg_transferConfig = GetNullableObjectAtIndex(args, 2);
        [api registerTransferMangerKey:arg_key config:arg_config transferConfig:arg_transferConfig completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface CosServiceApiCodecReader : FlutterStandardReader
@end
@implementation CosServiceApiCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [Bucket fromList:[self readValue]];
    
    case 129:     
      return [BucketContents fromList:[self readValue]];
    
    case 130:     
      return [CommonPrefixes fromList:[self readValue]];
    
    case 131:     
      return [Content fromList:[self readValue]];
    
    case 132:     
      return [ListAllMyBuckets fromList:[self readValue]];
    
    case 133:     
      return [Owner fromList:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface CosServiceApiCodecWriter : FlutterStandardWriter
@end
@implementation CosServiceApiCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[Bucket class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else 
  if ([value isKindOfClass:[BucketContents class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else 
  if ([value isKindOfClass:[CommonPrefixes class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else 
  if ([value isKindOfClass:[Content class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else 
  if ([value isKindOfClass:[ListAllMyBuckets class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else 
  if ([value isKindOfClass:[Owner class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface CosServiceApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation CosServiceApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[CosServiceApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[CosServiceApiCodecReader alloc] initWithData:data];
}
@end


NSObject<FlutterMessageCodec> *CosServiceApiGetCodec() {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    CosServiceApiCodecReaderWriter *readerWriter = [[CosServiceApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void CosServiceApiSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<CosServiceApi> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.headObject"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(headObjectServiceKey:bucket:region:cosPath:versionId:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(headObjectServiceKey:bucket:region:cosPath:versionId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_region = GetNullableObjectAtIndex(args, 2);
        NSString *arg_cosPath = GetNullableObjectAtIndex(args, 3);
        NSString *arg_versionId = GetNullableObjectAtIndex(args, 4);
        [api headObjectServiceKey:arg_serviceKey bucket:arg_bucket region:arg_region cosPath:arg_cosPath versionId:arg_versionId completion:^(NSDictionary<NSString *, NSString *> *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.deleteObject"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(deleteObjectServiceKey:bucket:region:cosPath:versionId:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(deleteObjectServiceKey:bucket:region:cosPath:versionId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_region = GetNullableObjectAtIndex(args, 2);
        NSString *arg_cosPath = GetNullableObjectAtIndex(args, 3);
        NSString *arg_versionId = GetNullableObjectAtIndex(args, 4);
        [api deleteObjectServiceKey:arg_serviceKey bucket:arg_bucket region:arg_region cosPath:arg_cosPath versionId:arg_versionId completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.getObjectUrl"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getObjectUrlBucket:region:key:serviceKey:error:)], @"CosServiceApi api (%@) doesn't respond to @selector(getObjectUrlBucket:region:key:serviceKey:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 0);
        NSString *arg_region = GetNullableObjectAtIndex(args, 1);
        NSString *arg_key = GetNullableObjectAtIndex(args, 2);
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 3);
        FlutterError *error;
        NSString *output = [api getObjectUrlBucket:arg_bucket region:arg_region key:arg_key serviceKey:arg_serviceKey error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.preBuildConnection"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(preBuildConnectionBucket:serviceKey:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(preBuildConnectionBucket:serviceKey:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 0);
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 1);
        [api preBuildConnectionBucket:arg_bucket serviceKey:arg_serviceKey completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.getService"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getServiceServiceKey:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(getServiceServiceKey:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        [api getServiceServiceKey:arg_serviceKey completion:^(ListAllMyBuckets *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.getBucket"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getBucketServiceKey:bucket:region:prefix:delimiter:encodingType:marker:maxKeys:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(getBucketServiceKey:bucket:region:prefix:delimiter:encodingType:marker:maxKeys:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_region = GetNullableObjectAtIndex(args, 2);
        NSString *arg_prefix = GetNullableObjectAtIndex(args, 3);
        NSString *arg_delimiter = GetNullableObjectAtIndex(args, 4);
        NSString *arg_encodingType = GetNullableObjectAtIndex(args, 5);
        NSString *arg_marker = GetNullableObjectAtIndex(args, 6);
        NSNumber *arg_maxKeys = GetNullableObjectAtIndex(args, 7);
        [api getBucketServiceKey:arg_serviceKey bucket:arg_bucket region:arg_region prefix:arg_prefix delimiter:arg_delimiter encodingType:arg_encodingType marker:arg_marker maxKeys:arg_maxKeys completion:^(BucketContents *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.putBucket"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(putBucketServiceKey:bucket:region:enableMAZ:cosacl:readAccount:writeAccount:readWriteAccount:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(putBucketServiceKey:bucket:region:enableMAZ:cosacl:readAccount:writeAccount:readWriteAccount:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_region = GetNullableObjectAtIndex(args, 2);
        NSNumber *arg_enableMAZ = GetNullableObjectAtIndex(args, 3);
        NSString *arg_cosacl = GetNullableObjectAtIndex(args, 4);
        NSString *arg_readAccount = GetNullableObjectAtIndex(args, 5);
        NSString *arg_writeAccount = GetNullableObjectAtIndex(args, 6);
        NSString *arg_readWriteAccount = GetNullableObjectAtIndex(args, 7);
        [api putBucketServiceKey:arg_serviceKey bucket:arg_bucket region:arg_region enableMAZ:arg_enableMAZ cosacl:arg_cosacl readAccount:arg_readAccount writeAccount:arg_writeAccount readWriteAccount:arg_readWriteAccount completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.headBucket"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(headBucketServiceKey:bucket:region:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(headBucketServiceKey:bucket:region:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_region = GetNullableObjectAtIndex(args, 2);
        [api headBucketServiceKey:arg_serviceKey bucket:arg_bucket region:arg_region completion:^(NSDictionary<NSString *, NSString *> *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.deleteBucket"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(deleteBucketServiceKey:bucket:region:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(deleteBucketServiceKey:bucket:region:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_region = GetNullableObjectAtIndex(args, 2);
        [api deleteBucketServiceKey:arg_serviceKey bucket:arg_bucket region:arg_region completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.getBucketAccelerate"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getBucketAccelerateServiceKey:bucket:region:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(getBucketAccelerateServiceKey:bucket:region:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_region = GetNullableObjectAtIndex(args, 2);
        [api getBucketAccelerateServiceKey:arg_serviceKey bucket:arg_bucket region:arg_region completion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.putBucketAccelerate"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(putBucketAccelerateServiceKey:bucket:region:enable:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(putBucketAccelerateServiceKey:bucket:region:enable:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_region = GetNullableObjectAtIndex(args, 2);
        NSNumber *arg_enable = GetNullableObjectAtIndex(args, 3);
        [api putBucketAccelerateServiceKey:arg_serviceKey bucket:arg_bucket region:arg_region enable:arg_enable completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.getBucketLocation"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getBucketLocationServiceKey:bucket:region:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(getBucketLocationServiceKey:bucket:region:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_region = GetNullableObjectAtIndex(args, 2);
        [api getBucketLocationServiceKey:arg_serviceKey bucket:arg_bucket region:arg_region completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.getBucketVersioning"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getBucketVersioningServiceKey:bucket:region:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(getBucketVersioningServiceKey:bucket:region:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_region = GetNullableObjectAtIndex(args, 2);
        [api getBucketVersioningServiceKey:arg_serviceKey bucket:arg_bucket region:arg_region completion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.putBucketVersioning"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(putBucketVersioningServiceKey:bucket:region:enable:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(putBucketVersioningServiceKey:bucket:region:enable:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_region = GetNullableObjectAtIndex(args, 2);
        NSNumber *arg_enable = GetNullableObjectAtIndex(args, 3);
        [api putBucketVersioningServiceKey:arg_serviceKey bucket:arg_bucket region:arg_region enable:arg_enable completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.doesBucketExist"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(doesBucketExistServiceKey:bucket:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(doesBucketExistServiceKey:bucket:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        [api doesBucketExistServiceKey:arg_serviceKey bucket:arg_bucket completion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.doesObjectExist"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(doesObjectExistServiceKey:bucket:cosPath:completion:)], @"CosServiceApi api (%@) doesn't respond to @selector(doesObjectExistServiceKey:bucket:cosPath:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_cosPath = GetNullableObjectAtIndex(args, 2);
        [api doesObjectExistServiceKey:arg_serviceKey bucket:arg_bucket cosPath:arg_cosPath completion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosServiceApi.cancelAll"
        binaryMessenger:binaryMessenger
        codec:CosServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cancelAllServiceKey:error:)], @"CosServiceApi api (%@) doesn't respond to @selector(cancelAllServiceKey:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_serviceKey = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api cancelAllServiceKey:arg_serviceKey error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
NSObject<FlutterMessageCodec> *CosTransferApiGetCodec() {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  sSharedObject = [FlutterStandardMessageCodec sharedInstance];
  return sSharedObject;
}

void CosTransferApiSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<CosTransferApi> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosTransferApi.upload"
        binaryMessenger:binaryMessenger
        codec:CosTransferApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(uploadTransferKey:bucket:cosPath:region:filePath:byteArr:uploadId:stroageClass:trafficLimit:resultCallbackKey:stateCallbackKey:progressCallbackKey:initMultipleUploadCallbackKey:error:)], @"CosTransferApi api (%@) doesn't respond to @selector(uploadTransferKey:bucket:cosPath:region:filePath:byteArr:uploadId:stroageClass:trafficLimit:resultCallbackKey:stateCallbackKey:progressCallbackKey:initMultipleUploadCallbackKey:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_transferKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_cosPath = GetNullableObjectAtIndex(args, 2);
        NSString *arg_region = GetNullableObjectAtIndex(args, 3);
        NSString *arg_filePath = GetNullableObjectAtIndex(args, 4);
        FlutterStandardTypedData *arg_byteArr = GetNullableObjectAtIndex(args, 5);
        NSString *arg_uploadId = GetNullableObjectAtIndex(args, 6);
        NSString *arg_stroageClass = GetNullableObjectAtIndex(args, 7);
        NSNumber *arg_trafficLimit = GetNullableObjectAtIndex(args, 8);
        NSNumber *arg_resultCallbackKey = GetNullableObjectAtIndex(args, 9);
        NSNumber *arg_stateCallbackKey = GetNullableObjectAtIndex(args, 10);
        NSNumber *arg_progressCallbackKey = GetNullableObjectAtIndex(args, 11);
        NSNumber *arg_initMultipleUploadCallbackKey = GetNullableObjectAtIndex(args, 12);
        FlutterError *error;
        NSString *output = [api uploadTransferKey:arg_transferKey bucket:arg_bucket cosPath:arg_cosPath region:arg_region filePath:arg_filePath byteArr:arg_byteArr uploadId:arg_uploadId stroageClass:arg_stroageClass trafficLimit:arg_trafficLimit resultCallbackKey:arg_resultCallbackKey stateCallbackKey:arg_stateCallbackKey progressCallbackKey:arg_progressCallbackKey initMultipleUploadCallbackKey:arg_initMultipleUploadCallbackKey error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosTransferApi.download"
        binaryMessenger:binaryMessenger
        codec:CosTransferApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(downloadTransferKey:bucket:cosPath:region:savePath:versionId:trafficLimit:resultCallbackKey:stateCallbackKey:progressCallbackKey:error:)], @"CosTransferApi api (%@) doesn't respond to @selector(downloadTransferKey:bucket:cosPath:region:savePath:versionId:trafficLimit:resultCallbackKey:stateCallbackKey:progressCallbackKey:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_transferKey = GetNullableObjectAtIndex(args, 0);
        NSString *arg_bucket = GetNullableObjectAtIndex(args, 1);
        NSString *arg_cosPath = GetNullableObjectAtIndex(args, 2);
        NSString *arg_region = GetNullableObjectAtIndex(args, 3);
        NSString *arg_savePath = GetNullableObjectAtIndex(args, 4);
        NSString *arg_versionId = GetNullableObjectAtIndex(args, 5);
        NSNumber *arg_trafficLimit = GetNullableObjectAtIndex(args, 6);
        NSNumber *arg_resultCallbackKey = GetNullableObjectAtIndex(args, 7);
        NSNumber *arg_stateCallbackKey = GetNullableObjectAtIndex(args, 8);
        NSNumber *arg_progressCallbackKey = GetNullableObjectAtIndex(args, 9);
        FlutterError *error;
        NSString *output = [api downloadTransferKey:arg_transferKey bucket:arg_bucket cosPath:arg_cosPath region:arg_region savePath:arg_savePath versionId:arg_versionId trafficLimit:arg_trafficLimit resultCallbackKey:arg_resultCallbackKey stateCallbackKey:arg_stateCallbackKey progressCallbackKey:arg_progressCallbackKey error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosTransferApi.pause"
        binaryMessenger:binaryMessenger
        codec:CosTransferApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(pauseTaskId:transferKey:error:)], @"CosTransferApi api (%@) doesn't respond to @selector(pauseTaskId:transferKey:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_taskId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_transferKey = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api pauseTaskId:arg_taskId transferKey:arg_transferKey error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosTransferApi.resume"
        binaryMessenger:binaryMessenger
        codec:CosTransferApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(resumeTaskId:transferKey:error:)], @"CosTransferApi api (%@) doesn't respond to @selector(resumeTaskId:transferKey:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_taskId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_transferKey = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api resumeTaskId:arg_taskId transferKey:arg_transferKey error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CosTransferApi.cancel"
        binaryMessenger:binaryMessenger
        codec:CosTransferApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cancelTaskId:transferKey:error:)], @"CosTransferApi api (%@) doesn't respond to @selector(cancelTaskId:transferKey:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_taskId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_transferKey = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api cancelTaskId:arg_taskId transferKey:arg_transferKey error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FlutterCosApiCodecReader : FlutterStandardReader
@end
@implementation FlutterCosApiCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [CosXmlClientException fromList:[self readValue]];
    
    case 129:     
      return [CosXmlServiceException fromList:[self readValue]];
    
    case 130:     
      return [SessionQCloudCredentials fromList:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface FlutterCosApiCodecWriter : FlutterStandardWriter
@end
@implementation FlutterCosApiCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[CosXmlClientException class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else 
  if ([value isKindOfClass:[CosXmlServiceException class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else 
  if ([value isKindOfClass:[SessionQCloudCredentials class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface FlutterCosApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FlutterCosApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FlutterCosApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FlutterCosApiCodecReader alloc] initWithData:data];
}
@end


NSObject<FlutterMessageCodec> *FlutterCosApiGetCodec() {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FlutterCosApiCodecReaderWriter *readerWriter = [[FlutterCosApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

@interface FlutterCosApi ()
@property (nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation FlutterCosApi

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)fetchSessionCredentialsWithCompletion:(void(^)(SessionQCloudCredentials *_Nullable, NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.FlutterCosApi.fetchSessionCredentials"
      binaryMessenger:self.binaryMessenger
      codec:FlutterCosApiGetCodec()];
  [channel sendMessage:nil reply:^(id reply) {
    SessionQCloudCredentials *output = reply;
    completion(output, nil);
  }];
}
- (void)resultSuccessCallbackTransferKey:(NSString *)arg_transferKey key:(NSNumber *)arg_key header:(nullable NSDictionary<NSString *, NSString *> *)arg_header completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.FlutterCosApi.resultSuccessCallback"
      binaryMessenger:self.binaryMessenger
      codec:FlutterCosApiGetCodec()];
  [channel sendMessage:@[arg_transferKey ?: [NSNull null], arg_key ?: [NSNull null], arg_header ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
- (void)resultFailCallbackTransferKey:(NSString *)arg_transferKey key:(NSNumber *)arg_key clientException:(nullable CosXmlClientException *)arg_clientException serviceException:(nullable CosXmlServiceException *)arg_serviceException completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.FlutterCosApi.resultFailCallback"
      binaryMessenger:self.binaryMessenger
      codec:FlutterCosApiGetCodec()];
  [channel sendMessage:@[arg_transferKey ?: [NSNull null], arg_key ?: [NSNull null], arg_clientException ?: [NSNull null], arg_serviceException ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
- (void)stateCallbackTransferKey:(NSString *)arg_transferKey key:(NSNumber *)arg_key state:(NSString *)arg_state completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.FlutterCosApi.stateCallback"
      binaryMessenger:self.binaryMessenger
      codec:FlutterCosApiGetCodec()];
  [channel sendMessage:@[arg_transferKey ?: [NSNull null], arg_key ?: [NSNull null], arg_state ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
- (void)progressCallbackTransferKey:(NSString *)arg_transferKey key:(NSNumber *)arg_key complete:(NSNumber *)arg_complete target:(NSNumber *)arg_target completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.FlutterCosApi.progressCallback"
      binaryMessenger:self.binaryMessenger
      codec:FlutterCosApiGetCodec()];
  [channel sendMessage:@[arg_transferKey ?: [NSNull null], arg_key ?: [NSNull null], arg_complete ?: [NSNull null], arg_target ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
- (void)initMultipleUploadCallbackTransferKey:(NSString *)arg_transferKey key:(NSNumber *)arg_key bucket:(NSString *)arg_bucket cosKey:(NSString *)arg_cosKey uploadId:(NSString *)arg_uploadId completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.FlutterCosApi.initMultipleUploadCallback"
      binaryMessenger:self.binaryMessenger
      codec:FlutterCosApiGetCodec()];
  [channel sendMessage:@[arg_transferKey ?: [NSNull null], arg_key ?: [NSNull null], arg_bucket ?: [NSNull null], arg_cosKey ?: [NSNull null], arg_uploadId ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
@end
