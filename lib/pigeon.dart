// Autogenerated from Pigeon (v4.2.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import
import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

class CosXmlServiceConfig {
  CosXmlServiceConfig({
    this.region,
    this.connectionTimeout,
    this.socketTimeout,
    this.isHttps,
    this.host,
    this.hostFormat,
    this.port,
    this.isDebuggable,
    this.signInUrl,
    this.userAgent,
    this.dnsCache,
    this.accelerate,
  });

  String? region;
  int? connectionTimeout;
  int? socketTimeout;
  bool? isHttps;
  String? host;
  String? hostFormat;
  int? port;
  bool? isDebuggable;
  bool? signInUrl;
  String? userAgent;
  bool? dnsCache;
  bool? accelerate;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['region'] = region;
    pigeonMap['connectionTimeout'] = connectionTimeout;
    pigeonMap['socketTimeout'] = socketTimeout;
    pigeonMap['isHttps'] = isHttps;
    pigeonMap['host'] = host;
    pigeonMap['hostFormat'] = hostFormat;
    pigeonMap['port'] = port;
    pigeonMap['isDebuggable'] = isDebuggable;
    pigeonMap['signInUrl'] = signInUrl;
    pigeonMap['userAgent'] = userAgent;
    pigeonMap['dnsCache'] = dnsCache;
    pigeonMap['accelerate'] = accelerate;
    return pigeonMap;
  }

  static CosXmlServiceConfig decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return CosXmlServiceConfig(
      region: pigeonMap['region'] as String?,
      connectionTimeout: pigeonMap['connectionTimeout'] as int?,
      socketTimeout: pigeonMap['socketTimeout'] as int?,
      isHttps: pigeonMap['isHttps'] as bool?,
      host: pigeonMap['host'] as String?,
      hostFormat: pigeonMap['hostFormat'] as String?,
      port: pigeonMap['port'] as int?,
      isDebuggable: pigeonMap['isDebuggable'] as bool?,
      signInUrl: pigeonMap['signInUrl'] as bool?,
      userAgent: pigeonMap['userAgent'] as String?,
      dnsCache: pigeonMap['dnsCache'] as bool?,
      accelerate: pigeonMap['accelerate'] as bool?,
    );
  }
}

class TransferConfig {
  TransferConfig({
    this.forceSimpleUpload,
    this.enableVerification,
    this.divisionForUpload,
    this.sliceSizeForUpload,
  });

  bool? forceSimpleUpload;
  bool? enableVerification;
  int? divisionForUpload;
  int? sliceSizeForUpload;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['forceSimpleUpload'] = forceSimpleUpload;
    pigeonMap['enableVerification'] = enableVerification;
    pigeonMap['divisionForUpload'] = divisionForUpload;
    pigeonMap['sliceSizeForUpload'] = sliceSizeForUpload;
    return pigeonMap;
  }

  static TransferConfig decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return TransferConfig(
      forceSimpleUpload: pigeonMap['forceSimpleUpload'] as bool?,
      enableVerification: pigeonMap['enableVerification'] as bool?,
      divisionForUpload: pigeonMap['divisionForUpload'] as int?,
      sliceSizeForUpload: pigeonMap['sliceSizeForUpload'] as int?,
    );
  }
}

class SessionQCloudCredentials {
  SessionQCloudCredentials({
    required this.secretId,
    required this.secretKey,
    required this.token,
    this.startTime,
    required this.expiredTime,
  });

  String secretId;
  String secretKey;
  String token;
  int? startTime;
  int expiredTime;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['secretId'] = secretId;
    pigeonMap['secretKey'] = secretKey;
    pigeonMap['token'] = token;
    pigeonMap['startTime'] = startTime;
    pigeonMap['expiredTime'] = expiredTime;
    return pigeonMap;
  }

  static SessionQCloudCredentials decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return SessionQCloudCredentials(
      secretId: pigeonMap['secretId']! as String,
      secretKey: pigeonMap['secretKey']! as String,
      token: pigeonMap['token']! as String,
      startTime: pigeonMap['startTime'] as int?,
      expiredTime: pigeonMap['expiredTime']! as int,
    );
  }
}

class CosXmlClientException {
  CosXmlClientException({
    required this.errorCode,
    this.message,
    this.details,
  });

  int errorCode;
  String? message;
  String? details;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['errorCode'] = errorCode;
    pigeonMap['message'] = message;
    pigeonMap['details'] = details;
    return pigeonMap;
  }

  static CosXmlClientException decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return CosXmlClientException(
      errorCode: pigeonMap['errorCode']! as int,
      message: pigeonMap['message'] as String?,
      details: pigeonMap['details'] as String?,
    );
  }
}

class CosXmlServiceException {
  CosXmlServiceException({
    required this.statusCode,
    this.httpMsg,
    this.requestId,
    this.errorCode,
    this.errorMessage,
    this.serviceName,
    this.details,
  });

  int statusCode;
  String? httpMsg;
  String? requestId;
  String? errorCode;
  String? errorMessage;
  String? serviceName;
  String? details;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['statusCode'] = statusCode;
    pigeonMap['httpMsg'] = httpMsg;
    pigeonMap['requestId'] = requestId;
    pigeonMap['errorCode'] = errorCode;
    pigeonMap['errorMessage'] = errorMessage;
    pigeonMap['serviceName'] = serviceName;
    pigeonMap['details'] = details;
    return pigeonMap;
  }

  static CosXmlServiceException decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return CosXmlServiceException(
      statusCode: pigeonMap['statusCode']! as int,
      httpMsg: pigeonMap['httpMsg'] as String?,
      requestId: pigeonMap['requestId'] as String?,
      errorCode: pigeonMap['errorCode'] as String?,
      errorMessage: pigeonMap['errorMessage'] as String?,
      serviceName: pigeonMap['serviceName'] as String?,
      details: pigeonMap['details'] as String?,
    );
  }
}

class Owner {
  Owner({
    required this.id,
    this.disPlayName,
  });

  /// 存储桶持有者的完整 ID
  String id;
  /// 存储桶持有者的名字
  String? disPlayName;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['id'] = id;
    pigeonMap['disPlayName'] = disPlayName;
    return pigeonMap;
  }

  static Owner decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return Owner(
      id: pigeonMap['id']! as String,
      disPlayName: pigeonMap['disPlayName'] as String?,
    );
  }
}

class Bucket {
  Bucket({
    required this.name,
    this.location,
    this.createDate,
    this.type,
  });

  /// 存储桶的名称
  String name;
  /// 存储桶所在地域
  String? location;
  /// 存储桶的创建时间，为 ISO8601 格式，例如2019-05-24T10:56:40Z
  String? createDate;
  String? type;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['name'] = name;
    pigeonMap['location'] = location;
    pigeonMap['createDate'] = createDate;
    pigeonMap['type'] = type;
    return pigeonMap;
  }

  static Bucket decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return Bucket(
      name: pigeonMap['name']! as String,
      location: pigeonMap['location'] as String?,
      createDate: pigeonMap['createDate'] as String?,
      type: pigeonMap['type'] as String?,
    );
  }
}

class ListAllMyBuckets {
  ListAllMyBuckets({
    required this.owner,
    required this.buckets,
  });

  /// 存储桶持有者信息
  Owner owner;
  /// 存储桶列表
  List<Bucket?> buckets;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['owner'] = owner.encode();
    pigeonMap['buckets'] = buckets;
    return pigeonMap;
  }

  static ListAllMyBuckets decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return ListAllMyBuckets(
      owner: Owner.decode(pigeonMap['owner']!)
,
      buckets: (pigeonMap['buckets'] as List<Object?>?)!.cast<Bucket?>(),
    );
  }
}

class CommonPrefixes {
  CommonPrefixes({
    required this.prefix,
  });

  /// Common Prefix 的前缀
  String prefix;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['prefix'] = prefix;
    return pigeonMap;
  }

  static CommonPrefixes decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return CommonPrefixes(
      prefix: pigeonMap['prefix']! as String,
    );
  }
}

class Content {
  Content({
    required this.key,
    required this.lastModified,
    required this.eTag,
    required this.size,
    required this.owner,
    required this.storageClass,
  });

  /// 对象键
  String key;
  /// 对象最后修改时间，为 ISO8601 格式，如2019-05-24T10:56:40Z
  String lastModified;
  /// 对象的实体标签（Entity Tag），是对象被创建时标识对象内容的信息标签，可用于检查对象的内容是否发生变化，
  /// 例如“8e0b617ca298a564c3331da28dcb50df”，此头部并不一定返回对象的 MD5 值，而是根据对象上传和加密方式而有所不同
  String eTag;
  /// 对象大小，单位为 Byte
  int size;
  /// 对象持有者信息
  Owner owner;
  /// 对象存储类型
  String storageClass;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['key'] = key;
    pigeonMap['lastModified'] = lastModified;
    pigeonMap['eTag'] = eTag;
    pigeonMap['size'] = size;
    pigeonMap['owner'] = owner.encode();
    pigeonMap['storageClass'] = storageClass;
    return pigeonMap;
  }

  static Content decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return Content(
      key: pigeonMap['key']! as String,
      lastModified: pigeonMap['lastModified']! as String,
      eTag: pigeonMap['eTag']! as String,
      size: pigeonMap['size']! as int,
      owner: Owner.decode(pigeonMap['owner']!)
,
      storageClass: pigeonMap['storageClass']! as String,
    );
  }
}

class BucketContents {
  BucketContents({
    required this.name,
    this.encodingType,
    this.prefix,
    this.marker,
    required this.maxKeys,
    required this.isTruncated,
    this.nextMarker,
    required this.contentsList,
    required this.commonPrefixesList,
    this.delimiter,
  });

  /// 存储桶的名称，格式为<BucketName-APPID>，例如examplebucket-1250000000
  String name;
  /// 编码格式，对应请求中的 encoding-type 参数，且仅当请求中指定了 encoding-type 参数才会返回该节点
  String? encodingType;
  /// 对象键匹配前缀，对应请求中的 prefix 参数
  String? prefix;
  /// 起始对象键标记，从该标记之后（不含）按照 UTF-8 字典序返回对象键条目，对应请求中的 marker 参数
  String? marker;
  /// 单次响应返回结果的最大条目数量，对应请求中的 max-keys 参数
  /// 注意：该参数会限制每一次 List 操作返回的最大条目数，COS 在每次 List 操作中将返回不超过 max-keys 所设定数值的条目。
  /// 如果由于您设置了 max-keys 参数，导致单次响应中未列出所有对象，COS 会返回一项 nextmarker 参数作为您下次 List 请求的入参，
  /// 以便您后续进行列出对象
  int maxKeys;
  /// 响应条目是否被截断，布尔值，例如 true 或 false
  bool isTruncated;
  /// 仅当响应条目有截断（IsTruncated 为 true）才会返回该节点，
  /// 该节点的值为当前响应条目中的最后一个对象键，当需要继续请求后续条目时，将该节点的值作为下一次请求的 marker 参数传入
  String? nextMarker;
  /// 对象条目
  List<Content?> contentsList;
  /// 从 prefix 或从头（如未指定 prefix）到首个 delimiter 之间相同的部分，
  /// 定义为 Common Prefix。仅当请求中指定了 delimiter 参数才有可能返回该节点
  List<CommonPrefixes?> commonPrefixesList;
  /// 分隔符，对应请求中的 delimiter 参数，且仅当请求中指定了 delimiter 参数才会返回该节点
  String? delimiter;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['name'] = name;
    pigeonMap['encodingType'] = encodingType;
    pigeonMap['prefix'] = prefix;
    pigeonMap['marker'] = marker;
    pigeonMap['maxKeys'] = maxKeys;
    pigeonMap['isTruncated'] = isTruncated;
    pigeonMap['nextMarker'] = nextMarker;
    pigeonMap['contentsList'] = contentsList;
    pigeonMap['commonPrefixesList'] = commonPrefixesList;
    pigeonMap['delimiter'] = delimiter;
    return pigeonMap;
  }

  static BucketContents decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return BucketContents(
      name: pigeonMap['name']! as String,
      encodingType: pigeonMap['encodingType'] as String?,
      prefix: pigeonMap['prefix'] as String?,
      marker: pigeonMap['marker'] as String?,
      maxKeys: pigeonMap['maxKeys']! as int,
      isTruncated: pigeonMap['isTruncated']! as bool,
      nextMarker: pigeonMap['nextMarker'] as String?,
      contentsList: (pigeonMap['contentsList'] as List<Object?>?)!.cast<Content?>(),
      commonPrefixesList: (pigeonMap['commonPrefixesList'] as List<Object?>?)!.cast<CommonPrefixes?>(),
      delimiter: pigeonMap['delimiter'] as String?,
    );
  }
}

class _CosApiCodec extends StandardMessageCodec{
  const _CosApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is CosXmlServiceConfig) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is TransferConfig) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return CosXmlServiceConfig.decode(readValue(buffer)!);
      
      case 129:       
        return TransferConfig.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class CosApi {
  /// Constructor for [CosApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  CosApi({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _CosApiCodec();

  Future<void> initWithPlainSecret(String arg_secretId, String arg_secretKey) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosApi.initWithPlainSecret', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_secretId, arg_secretKey]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> initWithSessionCredential() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosApi.initWithSessionCredential', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> setCloseBeacon(bool arg_isCloseBeacon) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosApi.setCloseBeacon', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_isCloseBeacon]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> registerDefaultService(CosXmlServiceConfig arg_config) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosApi.registerDefaultService', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_config]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> registerDefaultTransferManger(CosXmlServiceConfig arg_config, TransferConfig? arg_transferConfig) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosApi.registerDefaultTransferManger', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_config, arg_transferConfig]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> registerService(String arg_key, CosXmlServiceConfig arg_config) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosApi.registerService', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_key, arg_config]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> registerTransferManger(String arg_key, CosXmlServiceConfig arg_config, TransferConfig? arg_transferConfig) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosApi.registerTransferManger', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_key, arg_config, arg_transferConfig]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _CosServiceApiCodec extends StandardMessageCodec{
  const _CosServiceApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is Bucket) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is BucketContents) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
    if (value is CommonPrefixes) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else 
    if (value is Content) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else 
    if (value is ListAllMyBuckets) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else 
    if (value is Owner) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return Bucket.decode(readValue(buffer)!);
      
      case 129:       
        return BucketContents.decode(readValue(buffer)!);
      
      case 130:       
        return CommonPrefixes.decode(readValue(buffer)!);
      
      case 131:       
        return Content.decode(readValue(buffer)!);
      
      case 132:       
        return ListAllMyBuckets.decode(readValue(buffer)!);
      
      case 133:       
        return Owner.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class CosServiceApi {
  /// Constructor for [CosServiceApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  CosServiceApi({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _CosServiceApiCodec();

  Future<Map<String?, String?>> headObject(String arg_serviceKey, String arg_bucket, String? arg_region, String arg_cosPath, String? arg_versionId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.headObject', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_region, arg_cosPath, arg_versionId]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as Map<Object?, Object?>?)!.cast<String?, String?>();
    }
  }

  Future<void> deleteObject(String arg_serviceKey, String arg_bucket, String? arg_region, String arg_cosPath, String? arg_versionId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.deleteObject', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_region, arg_cosPath, arg_versionId]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<String> getObjectUrl(String arg_bucket, String arg_region, String arg_key, String arg_serviceKey) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.getObjectUrl', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_bucket, arg_region, arg_key, arg_serviceKey]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as String?)!;
    }
  }

  Future<void> preBuildConnection(String arg_bucket, String arg_serviceKey) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.preBuildConnection', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_bucket, arg_serviceKey]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<ListAllMyBuckets> getService(String arg_serviceKey) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.getService', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_serviceKey]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as ListAllMyBuckets?)!;
    }
  }

  Future<BucketContents> getBucket(String arg_serviceKey, String arg_bucket, String? arg_region, String? arg_prefix, String? arg_delimiter, String? arg_encodingType, String? arg_marker, int? arg_maxKeys) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.getBucket', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_region, arg_prefix, arg_delimiter, arg_encodingType, arg_marker, arg_maxKeys]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as BucketContents?)!;
    }
  }

  Future<void> putBucket(String arg_serviceKey, String arg_bucket, String? arg_region, bool? arg_enableMAZ, String? arg_cosacl, String? arg_readAccount, String? arg_writeAccount, String? arg_readWriteAccount) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.putBucket', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_region, arg_enableMAZ, arg_cosacl, arg_readAccount, arg_writeAccount, arg_readWriteAccount]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<Map<String?, String?>> headBucket(String arg_serviceKey, String arg_bucket, String? arg_region) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.headBucket', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_region]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as Map<Object?, Object?>?)!.cast<String?, String?>();
    }
  }

  Future<void> deleteBucket(String arg_serviceKey, String arg_bucket, String? arg_region) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.deleteBucket', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_region]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<bool> getBucketAccelerate(String arg_serviceKey, String arg_bucket, String? arg_region) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.getBucketAccelerate', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_region]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as bool?)!;
    }
  }

  Future<void> putBucketAccelerate(String arg_serviceKey, String arg_bucket, String? arg_region, bool arg_enable) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.putBucketAccelerate', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_region, arg_enable]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<String> getBucketLocation(String arg_serviceKey, String arg_bucket, String? arg_region) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.getBucketLocation', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_region]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as String?)!;
    }
  }

  Future<bool> getBucketVersioning(String arg_serviceKey, String arg_bucket, String? arg_region) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.getBucketVersioning', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_region]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as bool?)!;
    }
  }

  Future<void> putBucketVersioning(String arg_serviceKey, String arg_bucket, String? arg_region, bool arg_enable) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.putBucketVersioning', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_region, arg_enable]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<bool> doesBucketExist(String arg_serviceKey, String arg_bucket) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.doesBucketExist', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as bool?)!;
    }
  }

  Future<bool> doesObjectExist(String arg_serviceKey, String arg_bucket, String arg_cosPath) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.doesObjectExist', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_cosPath]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as bool?)!;
    }
  }

  Future<void> cancelAll(String arg_serviceKey) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.cancelAll', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_serviceKey]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}


class CosTransferApi {
  /// Constructor for [CosTransferApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  CosTransferApi({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = StandardMessageCodec();

  Future<String> upload(String arg_transferKey, String arg_bucket, String arg_cosPath, String? arg_region, String? arg_filePath, Uint8List? arg_byteArr, String? arg_uploadId, String? arg_stroageClass, int? arg_trafficLimit, int? arg_resultCallbackKey, int? arg_stateCallbackKey, int? arg_progressCallbackKey, int? arg_initMultipleUploadCallbackKey) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosTransferApi.upload', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_transferKey, arg_bucket, arg_cosPath, arg_region, arg_filePath, arg_byteArr, arg_uploadId, arg_stroageClass, arg_trafficLimit, arg_resultCallbackKey, arg_stateCallbackKey, arg_progressCallbackKey, arg_initMultipleUploadCallbackKey]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as String?)!;
    }
  }

  Future<String> download(String arg_transferKey, String arg_bucket, String arg_cosPath, String? arg_region, String arg_savePath, String? arg_versionId, int? arg_trafficLimit, int? arg_resultCallbackKey, int? arg_stateCallbackKey, int? arg_progressCallbackKey) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosTransferApi.download', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_transferKey, arg_bucket, arg_cosPath, arg_region, arg_savePath, arg_versionId, arg_trafficLimit, arg_resultCallbackKey, arg_stateCallbackKey, arg_progressCallbackKey]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as String?)!;
    }
  }

  Future<void> pause(String arg_taskId, String arg_transferKey) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosTransferApi.pause', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_taskId, arg_transferKey]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> resume(String arg_taskId, String arg_transferKey) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosTransferApi.resume', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_taskId, arg_transferKey]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> cancel(String arg_taskId, String arg_transferKey) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosTransferApi.cancel', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_taskId, arg_transferKey]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _FlutterCosApiCodec extends StandardMessageCodec{
  const _FlutterCosApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is CosXmlClientException) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is CosXmlServiceException) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
    if (value is SessionQCloudCredentials) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return CosXmlClientException.decode(readValue(buffer)!);
      
      case 129:       
        return CosXmlServiceException.decode(readValue(buffer)!);
      
      case 130:       
        return SessionQCloudCredentials.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}
abstract class FlutterCosApi {
  static const MessageCodec<Object?> codec = _FlutterCosApiCodec();

  Future<SessionQCloudCredentials> fetchSessionCredentials();
  void resultSuccessCallback(String transferKey, int key, Map<String?, String?>? header);
  void resultFailCallback(String transferKey, int key, CosXmlClientException? clientException, CosXmlServiceException? serviceException);
  void stateCallback(String transferKey, int key, String state);
  void progressCallback(String transferKey, int key, int complete, int target);
  void initMultipleUploadCallback(String transferKey, int key, String bucket, String cosKey, String uploadId);
  static void setup(FlutterCosApi? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterCosApi.fetchSessionCredentials', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          // ignore message
          final SessionQCloudCredentials output = await api.fetchSessionCredentials();
          return output;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterCosApi.resultSuccessCallback', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.resultSuccessCallback was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_transferKey = (args[0] as String?);
          assert(arg_transferKey != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.resultSuccessCallback was null, expected non-null String.');
          final int? arg_key = (args[1] as int?);
          assert(arg_key != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.resultSuccessCallback was null, expected non-null int.');
          final Map<String?, String?>? arg_header = (args[2] as Map<Object?, Object?>?)?.cast<String?, String?>();
          api.resultSuccessCallback(arg_transferKey!, arg_key!, arg_header);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterCosApi.resultFailCallback', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.resultFailCallback was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_transferKey = (args[0] as String?);
          assert(arg_transferKey != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.resultFailCallback was null, expected non-null String.');
          final int? arg_key = (args[1] as int?);
          assert(arg_key != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.resultFailCallback was null, expected non-null int.');
          final CosXmlClientException? arg_clientException = (args[2] as CosXmlClientException?);
          final CosXmlServiceException? arg_serviceException = (args[3] as CosXmlServiceException?);
          api.resultFailCallback(arg_transferKey!, arg_key!, arg_clientException, arg_serviceException);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterCosApi.stateCallback', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.stateCallback was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_transferKey = (args[0] as String?);
          assert(arg_transferKey != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.stateCallback was null, expected non-null String.');
          final int? arg_key = (args[1] as int?);
          assert(arg_key != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.stateCallback was null, expected non-null int.');
          final String? arg_state = (args[2] as String?);
          assert(arg_state != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.stateCallback was null, expected non-null String.');
          api.stateCallback(arg_transferKey!, arg_key!, arg_state!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterCosApi.progressCallback', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.progressCallback was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_transferKey = (args[0] as String?);
          assert(arg_transferKey != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.progressCallback was null, expected non-null String.');
          final int? arg_key = (args[1] as int?);
          assert(arg_key != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.progressCallback was null, expected non-null int.');
          final int? arg_complete = (args[2] as int?);
          assert(arg_complete != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.progressCallback was null, expected non-null int.');
          final int? arg_target = (args[3] as int?);
          assert(arg_target != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.progressCallback was null, expected non-null int.');
          api.progressCallback(arg_transferKey!, arg_key!, arg_complete!, arg_target!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterCosApi.initMultipleUploadCallback', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.initMultipleUploadCallback was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_transferKey = (args[0] as String?);
          assert(arg_transferKey != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.initMultipleUploadCallback was null, expected non-null String.');
          final int? arg_key = (args[1] as int?);
          assert(arg_key != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.initMultipleUploadCallback was null, expected non-null int.');
          final String? arg_bucket = (args[2] as String?);
          assert(arg_bucket != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.initMultipleUploadCallback was null, expected non-null String.');
          final String? arg_cosKey = (args[3] as String?);
          assert(arg_cosKey != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.initMultipleUploadCallback was null, expected non-null String.');
          final String? arg_uploadId = (args[4] as String?);
          assert(arg_uploadId != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.initMultipleUploadCallback was null, expected non-null String.');
          api.initMultipleUploadCallback(arg_transferKey!, arg_key!, arg_bucket!, arg_cosKey!, arg_uploadId!);
          return;
        });
      }
    }
  }
}
