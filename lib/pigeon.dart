// Autogenerated from Pigeon (v4.2.14), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import
import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

class CosXmlServiceConfig {
  CosXmlServiceConfig({
    this.region,
    this.connectionTimeout,
    this.socketTimeout,
    this.isHttps,
    this.host,
    this.hostFormat,
    this.port,
    this.isDebuggable,
    this.signInUrl,
    this.userAgent,
    this.dnsCache,
    this.accelerate,
    this.domainSwitch,
  });

  String? region;

  int? connectionTimeout;

  int? socketTimeout;

  bool? isHttps;

  String? host;

  String? hostFormat;

  int? port;

  bool? isDebuggable;

  bool? signInUrl;

  String? userAgent;

  bool? dnsCache;

  bool? accelerate;

  bool? domainSwitch;

  Object encode() {
    return <Object?>[
      region,
      connectionTimeout,
      socketTimeout,
      isHttps,
      host,
      hostFormat,
      port,
      isDebuggable,
      signInUrl,
      userAgent,
      dnsCache,
      accelerate,
      domainSwitch,
    ];
  }

  static CosXmlServiceConfig decode(Object result) {
    result as List<Object?>;
    return CosXmlServiceConfig(
      region: result[0] as String?,
      connectionTimeout: result[1] as int?,
      socketTimeout: result[2] as int?,
      isHttps: result[3] as bool?,
      host: result[4] as String?,
      hostFormat: result[5] as String?,
      port: result[6] as int?,
      isDebuggable: result[7] as bool?,
      signInUrl: result[8] as bool?,
      userAgent: result[9] as String?,
      dnsCache: result[10] as bool?,
      accelerate: result[11] as bool?,
      domainSwitch: result[12] as bool?,
    );
  }
}

class TransferConfig {
  TransferConfig({
    this.forceSimpleUpload,
    this.enableVerification,
    this.divisionForUpload,
    this.sliceSizeForUpload,
  });

  bool? forceSimpleUpload;

  bool? enableVerification;

  int? divisionForUpload;

  int? sliceSizeForUpload;

  Object encode() {
    return <Object?>[
      forceSimpleUpload,
      enableVerification,
      divisionForUpload,
      sliceSizeForUpload,
    ];
  }

  static TransferConfig decode(Object result) {
    result as List<Object?>;
    return TransferConfig(
      forceSimpleUpload: result[0] as bool?,
      enableVerification: result[1] as bool?,
      divisionForUpload: result[2] as int?,
      sliceSizeForUpload: result[3] as int?,
    );
  }
}

class STSCredentialScope {
  STSCredentialScope({
    required this.action,
    required this.region,
    this.bucket,
    this.prefix,
  });

  String action;

  String region;

  String? bucket;

  String? prefix;

  Object encode() {
    return <Object?>[
      action,
      region,
      bucket,
      prefix,
    ];
  }

  static STSCredentialScope decode(Object result) {
    result as List<Object?>;
    return STSCredentialScope(
      action: result[0]! as String,
      region: result[1]! as String,
      bucket: result[2] as String?,
      prefix: result[3] as String?,
    );
  }
}

class SessionQCloudCredentials {
  SessionQCloudCredentials({
    required this.secretId,
    required this.secretKey,
    required this.token,
    this.startTime,
    required this.expiredTime,
  });

  String secretId;

  String secretKey;

  String token;

  int? startTime;

  int expiredTime;

  Object encode() {
    return <Object?>[
      secretId,
      secretKey,
      token,
      startTime,
      expiredTime,
    ];
  }

  static SessionQCloudCredentials decode(Object result) {
    result as List<Object?>;
    return SessionQCloudCredentials(
      secretId: result[0]! as String,
      secretKey: result[1]! as String,
      token: result[2]! as String,
      startTime: result[3] as int?,
      expiredTime: result[4]! as int,
    );
  }
}

class CosXmlResult {
  CosXmlResult({
    this.eTag,
    this.accessUrl,
    this.callbackResult,
  });

  String? eTag;

  String? accessUrl;

  CallbackResult? callbackResult;

  Object encode() {
    return <Object?>[
      eTag,
      accessUrl,
      callbackResult?.encode(),
    ];
  }

  static CosXmlResult decode(Object result) {
    result as List<Object?>;
    return CosXmlResult(
      eTag: result[0] as String?,
      accessUrl: result[1] as String?,
      callbackResult: result[2] != null
          ? CallbackResult.decode(result[2]! as List<Object?>)
          : null,
    );
  }
}

class CallbackResult {
  CallbackResult({
    required this.status,
    this.callbackBody,
    this.error,
  });

  /// Callback 是否成功。枚举值，支持 200、203。200表示上传成功、回调成功；203表示上传成功，回调失败
  int status;

  /// Status为200时，说明上传成功、回调成功，返回 CallbackBody
  String? callbackBody;

  /// Status为203时，说明Callback，返回 Error，说明回调失败信息
  CallbackResultError? error;

  Object encode() {
    return <Object?>[
      status,
      callbackBody,
      error?.encode(),
    ];
  }

  static CallbackResult decode(Object result) {
    result as List<Object?>;
    return CallbackResult(
      status: result[0]! as int,
      callbackBody: result[1] as String?,
      error: result[2] != null
          ? CallbackResultError.decode(result[2]! as List<Object?>)
          : null,
    );
  }
}

class CallbackResultError {
  CallbackResultError({
    this.code,
    this.message,
  });

  /// 回调失败信息的错误码，例如CallbackFailed
  String? code;

  /// Callback 失败的错误信息
  String? message;

  Object encode() {
    return <Object?>[
      code,
      message,
    ];
  }

  static CallbackResultError decode(Object result) {
    result as List<Object?>;
    return CallbackResultError(
      code: result[0] as String?,
      message: result[1] as String?,
    );
  }
}

class CosXmlClientException {
  CosXmlClientException({
    required this.errorCode,
    this.message,
    this.details,
  });

  int errorCode;

  String? message;

  String? details;

  Object encode() {
    return <Object?>[
      errorCode,
      message,
      details,
    ];
  }

  static CosXmlClientException decode(Object result) {
    result as List<Object?>;
    return CosXmlClientException(
      errorCode: result[0]! as int,
      message: result[1] as String?,
      details: result[2] as String?,
    );
  }
}

class CosXmlServiceException {
  CosXmlServiceException({
    required this.statusCode,
    this.httpMsg,
    this.requestId,
    this.errorCode,
    this.errorMessage,
    this.serviceName,
    this.details,
  });

  int statusCode;

  String? httpMsg;

  String? requestId;

  String? errorCode;

  String? errorMessage;

  String? serviceName;

  String? details;

  Object encode() {
    return <Object?>[
      statusCode,
      httpMsg,
      requestId,
      errorCode,
      errorMessage,
      serviceName,
      details,
    ];
  }

  static CosXmlServiceException decode(Object result) {
    result as List<Object?>;
    return CosXmlServiceException(
      statusCode: result[0]! as int,
      httpMsg: result[1] as String?,
      requestId: result[2] as String?,
      errorCode: result[3] as String?,
      errorMessage: result[4] as String?,
      serviceName: result[5] as String?,
      details: result[6] as String?,
    );
  }
}

class Owner {
  Owner({
    required this.id,
    this.disPlayName,
  });

  /// 存储桶持有者的完整 ID
  String id;

  /// 存储桶持有者的名字
  String? disPlayName;

  Object encode() {
    return <Object?>[
      id,
      disPlayName,
    ];
  }

  static Owner decode(Object result) {
    result as List<Object?>;
    return Owner(
      id: result[0]! as String,
      disPlayName: result[1] as String?,
    );
  }
}

class Bucket {
  Bucket({
    required this.name,
    this.location,
    this.createDate,
    this.type,
  });

  /// 存储桶的名称
  String name;

  /// 存储桶所在地域
  String? location;

  /// 存储桶的创建时间，为 ISO8601 格式，例如2019-05-24T10:56:40Z
  String? createDate;

  String? type;

  Object encode() {
    return <Object?>[
      name,
      location,
      createDate,
      type,
    ];
  }

  static Bucket decode(Object result) {
    result as List<Object?>;
    return Bucket(
      name: result[0]! as String,
      location: result[1] as String?,
      createDate: result[2] as String?,
      type: result[3] as String?,
    );
  }
}

class ListAllMyBuckets {
  ListAllMyBuckets({
    required this.owner,
    required this.buckets,
  });

  /// 存储桶持有者信息
  Owner owner;

  /// 存储桶列表
  List<Bucket?> buckets;

  Object encode() {
    return <Object?>[
      owner.encode(),
      buckets,
    ];
  }

  static ListAllMyBuckets decode(Object result) {
    result as List<Object?>;
    return ListAllMyBuckets(
      owner: Owner.decode(result[0]! as List<Object?>)
,
      buckets: (result[1] as List<Object?>?)!.cast<Bucket?>(),
    );
  }
}

class CommonPrefixes {
  CommonPrefixes({
    required this.prefix,
  });

  /// Common Prefix 的前缀
  String prefix;

  Object encode() {
    return <Object?>[
      prefix,
    ];
  }

  static CommonPrefixes decode(Object result) {
    result as List<Object?>;
    return CommonPrefixes(
      prefix: result[0]! as String,
    );
  }
}

class Content {
  Content({
    required this.key,
    required this.lastModified,
    required this.eTag,
    required this.size,
    required this.owner,
    required this.storageClass,
  });

  /// 对象键
  String key;

  /// 对象最后修改时间，为 ISO8601 格式，如2019-05-24T10:56:40Z
  String lastModified;

  /// 对象的实体标签（Entity Tag），是对象被创建时标识对象内容的信息标签，可用于检查对象的内容是否发生变化，
  /// 例如“8e0b617ca298a564c3331da28dcb50df”，此头部并不一定返回对象的 MD5 值，而是根据对象上传和加密方式而有所不同
  String eTag;

  /// 对象大小，单位为 Byte
  int size;

  /// 对象持有者信息
  Owner owner;

  /// 对象存储类型
  String storageClass;

  Object encode() {
    return <Object?>[
      key,
      lastModified,
      eTag,
      size,
      owner.encode(),
      storageClass,
    ];
  }

  static Content decode(Object result) {
    result as List<Object?>;
    return Content(
      key: result[0]! as String,
      lastModified: result[1]! as String,
      eTag: result[2]! as String,
      size: result[3]! as int,
      owner: Owner.decode(result[4]! as List<Object?>)
,
      storageClass: result[5]! as String,
    );
  }
}

class BucketContents {
  BucketContents({
    required this.name,
    this.encodingType,
    this.prefix,
    this.marker,
    required this.maxKeys,
    required this.isTruncated,
    this.nextMarker,
    required this.contentsList,
    required this.commonPrefixesList,
    this.delimiter,
  });

  /// 存储桶的名称，格式为<BucketName-APPID>，例如examplebucket-1250000000
  String name;

  /// 编码格式，对应请求中的 encoding-type 参数，且仅当请求中指定了 encoding-type 参数才会返回该节点
  String? encodingType;

  /// 对象键匹配前缀，对应请求中的 prefix 参数
  String? prefix;

  /// 起始对象键标记，从该标记之后（不含）按照 UTF-8 字典序返回对象键条目，对应请求中的 marker 参数
  String? marker;

  /// 单次响应返回结果的最大条目数量，对应请求中的 max-keys 参数
  /// 注意：该参数会限制每一次 List 操作返回的最大条目数，COS 在每次 List 操作中将返回不超过 max-keys 所设定数值的条目。
  /// 如果由于您设置了 max-keys 参数，导致单次响应中未列出所有对象，COS 会返回一项 nextmarker 参数作为您下次 List 请求的入参，
  /// 以便您后续进行列出对象
  int maxKeys;

  /// 响应条目是否被截断，布尔值，例如 true 或 false
  bool isTruncated;

  /// 仅当响应条目有截断（IsTruncated 为 true）才会返回该节点，
  /// 该节点的值为当前响应条目中的最后一个对象键，当需要继续请求后续条目时，将该节点的值作为下一次请求的 marker 参数传入
  String? nextMarker;

  /// 对象条目
  List<Content?> contentsList;

  /// 从 prefix 或从头（如未指定 prefix）到首个 delimiter 之间相同的部分，
  /// 定义为 Common Prefix。仅当请求中指定了 delimiter 参数才有可能返回该节点
  List<CommonPrefixes?> commonPrefixesList;

  /// 分隔符，对应请求中的 delimiter 参数，且仅当请求中指定了 delimiter 参数才会返回该节点
  String? delimiter;

  Object encode() {
    return <Object?>[
      name,
      encodingType,
      prefix,
      marker,
      maxKeys,
      isTruncated,
      nextMarker,
      contentsList,
      commonPrefixesList,
      delimiter,
    ];
  }

  static BucketContents decode(Object result) {
    result as List<Object?>;
    return BucketContents(
      name: result[0]! as String,
      encodingType: result[1] as String?,
      prefix: result[2] as String?,
      marker: result[3] as String?,
      maxKeys: result[4]! as int,
      isTruncated: result[5]! as bool,
      nextMarker: result[6] as String?,
      contentsList: (result[7] as List<Object?>?)!.cast<Content?>(),
      commonPrefixesList: (result[8] as List<Object?>?)!.cast<CommonPrefixes?>(),
      delimiter: result[9] as String?,
    );
  }
}

class _CosApiCodec extends StandardMessageCodec {
  const _CosApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is CosXmlServiceConfig) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is TransferConfig) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return CosXmlServiceConfig.decode(readValue(buffer)!);
      
      case 129:       
        return TransferConfig.decode(readValue(buffer)!);
      
      default:

        return super.readValueOfType(type, buffer);
      
    }
  }
}

class CosApi {
  /// Constructor for [CosApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  CosApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _CosApiCodec();

  Future<void> initWithPlainSecret(String arg_secretId, String arg_secretKey) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosApi.initWithPlainSecret', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_secretId, arg_secretKey]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> initWithSessionCredential() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosApi.initWithSessionCredential', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> initWithScopeLimitCredential() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosApi.initWithScopeLimitCredential', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> initCustomerDNS(Map<String?, List<String?>?> arg_dnsMap) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosApi.initCustomerDNS', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_dnsMap]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> initCustomerDNSFetch() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosApi.initCustomerDNSFetch', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> forceInvalidationCredential() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosApi.forceInvalidationCredential', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setCloseBeacon(bool arg_isCloseBeacon) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosApi.setCloseBeacon', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_isCloseBeacon]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<String> registerDefaultService(CosXmlServiceConfig arg_config) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosApi.registerDefaultService', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_config]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as String?)!;
    }
  }

  Future<String> registerDefaultTransferManger(CosXmlServiceConfig arg_config, TransferConfig? arg_transferConfig) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosApi.registerDefaultTransferManger', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_config, arg_transferConfig]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as String?)!;
    }
  }

  Future<String> registerService(String arg_key, CosXmlServiceConfig arg_config) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosApi.registerService', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_key, arg_config]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as String?)!;
    }
  }

  Future<String> registerTransferManger(String arg_key, CosXmlServiceConfig arg_config, TransferConfig? arg_transferConfig) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosApi.registerTransferManger', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_key, arg_config, arg_transferConfig]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as String?)!;
    }
  }
}

class _CosServiceApiCodec extends StandardMessageCodec {
  const _CosServiceApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is Bucket) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is BucketContents) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is CommonPrefixes) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is Content) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is ListAllMyBuckets) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else if (value is Owner) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return Bucket.decode(readValue(buffer)!);
      
      case 129:       
        return BucketContents.decode(readValue(buffer)!);
      
      case 130:       
        return CommonPrefixes.decode(readValue(buffer)!);
      
      case 131:       
        return Content.decode(readValue(buffer)!);
      
      case 132:       
        return ListAllMyBuckets.decode(readValue(buffer)!);
      
      case 133:       
        return Owner.decode(readValue(buffer)!);
      
      default:

        return super.readValueOfType(type, buffer);
      
    }
  }
}

class CosServiceApi {
  /// Constructor for [CosServiceApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  CosServiceApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _CosServiceApiCodec();

  Future<Map<String?, String?>> headObject(String arg_serviceKey, String arg_bucket, String? arg_region, String arg_cosPath, String? arg_versionId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.headObject', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_region, arg_cosPath, arg_versionId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as Map<Object?, Object?>?)!.cast<String?, String?>();
    }
  }

  Future<void> deleteObject(String arg_serviceKey, String arg_bucket, String? arg_region, String arg_cosPath, String? arg_versionId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.deleteObject', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_region, arg_cosPath, arg_versionId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<String> getObjectUrl(String arg_bucket, String arg_region, String arg_cosPath, String arg_serviceKey) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.getObjectUrl', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_bucket, arg_region, arg_cosPath, arg_serviceKey]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as String?)!;
    }
  }

  Future<String> getPresignedUrl(String arg_serviceKey, String arg_bucket, String arg_cosPath, int? arg_signValidTime, bool? arg_signHost, Map<String?, String?>? arg_parameters, String? arg_region) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.getPresignedUrl', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_cosPath, arg_signValidTime, arg_signHost, arg_parameters, arg_region]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as String?)!;
    }
  }

  Future<void> preBuildConnection(String arg_bucket, String arg_serviceKey) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.preBuildConnection', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_bucket, arg_serviceKey]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<ListAllMyBuckets> getService(String arg_serviceKey) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.getService', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_serviceKey]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as ListAllMyBuckets?)!;
    }
  }

  Future<BucketContents> getBucket(String arg_serviceKey, String arg_bucket, String? arg_region, String? arg_prefix, String? arg_delimiter, String? arg_encodingType, String? arg_marker, int? arg_maxKeys) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.getBucket', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_region, arg_prefix, arg_delimiter, arg_encodingType, arg_marker, arg_maxKeys]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as BucketContents?)!;
    }
  }

  Future<void> putBucket(String arg_serviceKey, String arg_bucket, String? arg_region, bool? arg_enableMAZ, String? arg_cosacl, String? arg_readAccount, String? arg_writeAccount, String? arg_readWriteAccount) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.putBucket', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_region, arg_enableMAZ, arg_cosacl, arg_readAccount, arg_writeAccount, arg_readWriteAccount]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<Map<String?, String?>> headBucket(String arg_serviceKey, String arg_bucket, String? arg_region) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.headBucket', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_region]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as Map<Object?, Object?>?)!.cast<String?, String?>();
    }
  }

  Future<void> deleteBucket(String arg_serviceKey, String arg_bucket, String? arg_region) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.deleteBucket', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_region]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool> getBucketAccelerate(String arg_serviceKey, String arg_bucket, String? arg_region) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.getBucketAccelerate', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_region]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }

  Future<void> putBucketAccelerate(String arg_serviceKey, String arg_bucket, String? arg_region, bool arg_enable) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.putBucketAccelerate', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_region, arg_enable]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<String> getBucketLocation(String arg_serviceKey, String arg_bucket, String? arg_region) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.getBucketLocation', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_region]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as String?)!;
    }
  }

  Future<bool> getBucketVersioning(String arg_serviceKey, String arg_bucket, String? arg_region) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.getBucketVersioning', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_region]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }

  Future<void> putBucketVersioning(String arg_serviceKey, String arg_bucket, String? arg_region, bool arg_enable) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.putBucketVersioning', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_region, arg_enable]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool> doesBucketExist(String arg_serviceKey, String arg_bucket) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.doesBucketExist', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }

  Future<bool> doesObjectExist(String arg_serviceKey, String arg_bucket, String arg_cosPath) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.doesObjectExist', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_serviceKey, arg_bucket, arg_cosPath]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }

  Future<void> cancelAll(String arg_serviceKey) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosServiceApi.cancelAll', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_serviceKey]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}


class CosTransferApi {
  /// Constructor for [CosTransferApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  CosTransferApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = StandardMessageCodec();

  Future<String> upload(String arg_transferKey, String arg_bucket, String arg_cosPath, String? arg_region, String? arg_filePath, Uint8List? arg_byteArr, String? arg_uploadId, String? arg_stroageClass, int? arg_trafficLimit, String? arg_callbackParam, int? arg_resultCallbackKey, int? arg_stateCallbackKey, int? arg_progressCallbackKey, int? arg_initMultipleUploadCallbackKey) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosTransferApi.upload', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_transferKey, arg_bucket, arg_cosPath, arg_region, arg_filePath, arg_byteArr, arg_uploadId, arg_stroageClass, arg_trafficLimit, arg_callbackParam, arg_resultCallbackKey, arg_stateCallbackKey, arg_progressCallbackKey, arg_initMultipleUploadCallbackKey]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as String?)!;
    }
  }

  Future<String> download(String arg_transferKey, String arg_bucket, String arg_cosPath, String? arg_region, String arg_savePath, String? arg_versionId, int? arg_trafficLimit, int? arg_resultCallbackKey, int? arg_stateCallbackKey, int? arg_progressCallbackKey) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosTransferApi.download', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_transferKey, arg_bucket, arg_cosPath, arg_region, arg_savePath, arg_versionId, arg_trafficLimit, arg_resultCallbackKey, arg_stateCallbackKey, arg_progressCallbackKey]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as String?)!;
    }
  }

  Future<void> pause(String arg_taskId, String arg_transferKey) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosTransferApi.pause', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_taskId, arg_transferKey]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> resume(String arg_taskId, String arg_transferKey) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosTransferApi.resume', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_taskId, arg_transferKey]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> cancel(String arg_taskId, String arg_transferKey) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CosTransferApi.cancel', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_taskId, arg_transferKey]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

class _FlutterCosApiCodec extends StandardMessageCodec {
  const _FlutterCosApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is CallbackResult) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is CallbackResultError) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is CosXmlClientException) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is CosXmlResult) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is CosXmlServiceException) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else if (value is STSCredentialScope) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else if (value is SessionQCloudCredentials) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return CallbackResult.decode(readValue(buffer)!);
      
      case 129:       
        return CallbackResultError.decode(readValue(buffer)!);
      
      case 130:       
        return CosXmlClientException.decode(readValue(buffer)!);
      
      case 131:       
        return CosXmlResult.decode(readValue(buffer)!);
      
      case 132:       
        return CosXmlServiceException.decode(readValue(buffer)!);
      
      case 133:       
        return STSCredentialScope.decode(readValue(buffer)!);
      
      case 134:       
        return SessionQCloudCredentials.decode(readValue(buffer)!);
      
      default:

        return super.readValueOfType(type, buffer);
      
    }
  }
}

abstract class FlutterCosApi {
  static const MessageCodec<Object?> codec = _FlutterCosApiCodec();

  Future<SessionQCloudCredentials> fetchSessionCredentials();

  Future<SessionQCloudCredentials> fetchScopeLimitCredentials(List<STSCredentialScope?> stsCredentialScopes);

  /// 获取dns记录
  /// @param domain 域名
  /// @return ip集合
  Future<List<String?>?> fetchDns(String domain);

  void resultSuccessCallback(String transferKey, int key, Map<String?, String?>? header, CosXmlResult? result);

  void resultFailCallback(String transferKey, int key, CosXmlClientException? clientException, CosXmlServiceException? serviceException);

  void stateCallback(String transferKey, int key, String state);

  void progressCallback(String transferKey, int key, int complete, int target);

  void initMultipleUploadCallback(String transferKey, int key, String bucket, String cosKey, String uploadId);

  static void setup(FlutterCosApi? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterCosApi.fetchSessionCredentials', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          // ignore message
          final SessionQCloudCredentials output = await api.fetchSessionCredentials();
          return output;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterCosApi.fetchScopeLimitCredentials', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.FlutterCosApi.fetchScopeLimitCredentials was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final List<STSCredentialScope?>? arg_stsCredentialScopes = (args[0] as List<Object?>?)?.cast<STSCredentialScope?>();
          assert(arg_stsCredentialScopes != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.fetchScopeLimitCredentials was null, expected non-null List<STSCredentialScope?>.');
          final SessionQCloudCredentials output = await api.fetchScopeLimitCredentials(arg_stsCredentialScopes!);
          return output;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterCosApi.fetchDns', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.FlutterCosApi.fetchDns was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_domain = (args[0] as String?);
          assert(arg_domain != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.fetchDns was null, expected non-null String.');
          final List<String?>? output = await api.fetchDns(arg_domain!);
          return output;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterCosApi.resultSuccessCallback', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.FlutterCosApi.resultSuccessCallback was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_transferKey = (args[0] as String?);
          assert(arg_transferKey != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.resultSuccessCallback was null, expected non-null String.');
          final int? arg_key = (args[1] as int?);
          assert(arg_key != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.resultSuccessCallback was null, expected non-null int.');
          final Map<String?, String?>? arg_header = (args[2] as Map<Object?, Object?>?)?.cast<String?, String?>();
          final CosXmlResult? arg_result = (args[3] as CosXmlResult?);
          api.resultSuccessCallback(arg_transferKey!, arg_key!, arg_header, arg_result);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterCosApi.resultFailCallback', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.FlutterCosApi.resultFailCallback was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_transferKey = (args[0] as String?);
          assert(arg_transferKey != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.resultFailCallback was null, expected non-null String.');
          final int? arg_key = (args[1] as int?);
          assert(arg_key != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.resultFailCallback was null, expected non-null int.');
          final CosXmlClientException? arg_clientException = (args[2] as CosXmlClientException?);
          final CosXmlServiceException? arg_serviceException = (args[3] as CosXmlServiceException?);
          api.resultFailCallback(arg_transferKey!, arg_key!, arg_clientException, arg_serviceException);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterCosApi.stateCallback', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.FlutterCosApi.stateCallback was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_transferKey = (args[0] as String?);
          assert(arg_transferKey != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.stateCallback was null, expected non-null String.');
          final int? arg_key = (args[1] as int?);
          assert(arg_key != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.stateCallback was null, expected non-null int.');
          final String? arg_state = (args[2] as String?);
          assert(arg_state != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.stateCallback was null, expected non-null String.');
          api.stateCallback(arg_transferKey!, arg_key!, arg_state!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterCosApi.progressCallback', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.FlutterCosApi.progressCallback was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_transferKey = (args[0] as String?);
          assert(arg_transferKey != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.progressCallback was null, expected non-null String.');
          final int? arg_key = (args[1] as int?);
          assert(arg_key != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.progressCallback was null, expected non-null int.');
          final int? arg_complete = (args[2] as int?);
          assert(arg_complete != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.progressCallback was null, expected non-null int.');
          final int? arg_target = (args[3] as int?);
          assert(arg_target != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.progressCallback was null, expected non-null int.');
          api.progressCallback(arg_transferKey!, arg_key!, arg_complete!, arg_target!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterCosApi.initMultipleUploadCallback', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.FlutterCosApi.initMultipleUploadCallback was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_transferKey = (args[0] as String?);
          assert(arg_transferKey != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.initMultipleUploadCallback was null, expected non-null String.');
          final int? arg_key = (args[1] as int?);
          assert(arg_key != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.initMultipleUploadCallback was null, expected non-null int.');
          final String? arg_bucket = (args[2] as String?);
          assert(arg_bucket != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.initMultipleUploadCallback was null, expected non-null String.');
          final String? arg_cosKey = (args[3] as String?);
          assert(arg_cosKey != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.initMultipleUploadCallback was null, expected non-null String.');
          final String? arg_uploadId = (args[4] as String?);
          assert(arg_uploadId != null, 'Argument for dev.flutter.pigeon.FlutterCosApi.initMultipleUploadCallback was null, expected non-null String.');
          api.initMultipleUploadCallback(arg_transferKey!, arg_key!, arg_bucket!, arg_cosKey!, arg_uploadId!);
          return;
        });
      }
    }
  }
}
